ProtoObject subclass: #Object	instanceVariableNames: ''	classVariableNames: 'DependentsFields'	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Object commentStamp: '<historical>' prior: 0!Object is the root class for almost all of the other classes in the class hierarchy. The exceptions are ProtoObject (the superclass of Object) and its subclasses.Class Object provides default behavior common to all normal objects, such as access, copying, comparison, error handling, message sending, and reflection. Also utility messages that all objects should respond to are defined here.Object has no instance variables, nor should any be added. This is due to several classes of objects that inherit from Object that have special implementations (SmallInteger and UndefinedObject for example) or the VM knows about and depends on the structure and layout of certain standard classes.Class Variables:	DependentsFields		an IdentityDictionary		Provides a virtual 'dependents' field so that any object may have one		or more dependent views, synchronized by the changed:/update: protocol.		Note that class Model has a real slot for its dependents, and overrides		the associated protocol with more efficient implementations.Because Object is the root of the inheritance tree, methods are often defined in Object to give all objects special behaviors needed by certain subsystems or applications, or to respond to certain general test messages such as isMorph.Miscellanous Discussions.About at: index accepting float and not only integers This behavior is also free in the sense that the failure code is only invoked when theprimitive fails and so adds nothing to the cost of successful accesses,which are the high dynamic frequency operation.  It will also show up underprofiling if one is concerned about efficiency, and so isn't a hidden cost.It is also in keeping with Smalltalk's mixed mode/arbitrary precisionimplicit coercion number system that one *can* use fractions or floats asindices.  Stripping out coercions like this will make the system more brittle.  So please do *not* remove this "hack".  I think it's a feature and a useful  one.Can you give me an example that demonstrates the usefulness of thisfeature?| a r |a := Array new: 10 withAll: 0.r := Random new.100 timesRepeat: [| v | v := r next * 10 + 1. a at: v put: (a at: v) + 1].ai.e. I didn't have to provide an explicit rounding step.  That's useful.  But in general anywhere where an index is derived by some calculation not having to provide the rounding step could be useful/helpful/more concise.  e.g. (n roundTo: 0.1) * 10 vs ((n roundTo: 0.1) * 10) asInteger.Some thought went into the original choice.  It is not a hack but there by intent.  The integers are simply a subset of the reals and forcing the programmer to use them is favouring the machine above the programmer.But I think you should justify getting rid of it rather than my having to justify keeping it.  Getting rid of it risks breaking code.  If it is there but does not harm then why get rid of it?best Eliot Miranda !!Object methodsFor: '*Morphic-Core' stamp: 'JuanVuletich 11/1/2010 15:18'!currentWorld	"Answer a morphic world that is the current UI focus."	^UIManager default currentWorld! !!Object methodsFor: 'block support' stamp: 'ClementBera 6/28/2013 10:20'!mustBeBooleanIn: context	"context is the where the non-boolean error occurred. Rewind context to before jump then raise error."		"Some constructs are optimized in the compiler :	#whileTrue:	#whileFalse:	#ifTrue:	#ifFalse:	#ifTrue:ifFalse:	#ifFalse:ifTrue:	So you cannot by default use them on non boolean objects."		"If you really need to use optimized constructs, you can enable Opal compiler and do one of the following :		- recompile your method with the pragma : <compilerOptions: #(+ optIlineNone)>		- recompile your class with the method : MyClass class>>compiler 			^ super compiler options: #(+ optIlineNone)		- call from this method by Object>>#mustBeBooleanInMagic:"	| proceedValue |		context skipBackBeforeJump.	proceedValue := NonBooleanReceiver new		object: self;		signal: 'proceed for truth.'.	^ proceedValue ~~ false! !!Object methodsFor: 'block support' stamp: 'CamilleTeruel 7/29/2014 15:44'!mustBeBoolean	"Catches attempts to test truth of non-Booleans.  This message is sent from the VM.  The sending context is rewound to just before the jump causing this exception."	^ self mustBeBooleanInMagic: thisContext sender! !!Object methodsFor: 'updating' stamp: 'MarcusDenker 6/11/2010 11:36'!changed: anAspect with: anObject	"Receiver changed. The change is denoted by the argument anAspect. 	Usually the argument is a Symbol that is part of the dependent's change 	protocol. Inform all of the dependents. Also pass anObject for additional information."	self dependents do: [:aDependent | aDependent update: anAspect with: anObject]! !!Object methodsFor: 'updating'!changed	"Receiver changed in a general way; inform all the dependents by 	sending each dependent an update: message."	self changed: self! !!Object methodsFor: 'updating'!changed: aParameter 	"Receiver changed. The change is denoted by the argument aParameter. 	Usually the argument is a Symbol that is part of the dependent's change 	protocol. Inform all of the dependents."	self dependents do: [:aDependent | aDependent update: aParameter]! !!Object methodsFor: 'updating' stamp: 'nk 2/17/2004 11:13'!update: anAspect with: anObject	"Receive a change notice from an object of whom the receiver is a 	dependent. The default behavior is to call update:,	which by default does nothing; a subclass might want 	to change itself in some way."	^ self update: anAspect! !!Object methodsFor: 'updating'!update: aParameter 	"Receive a change notice from an object of whom the receiver is a 	dependent. The default behavior is to do nothing; a subclass might want 	to change itself in some way."	^ self! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 11/5/2011 10:49'!logCr      self logCr: self printString! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 5/27/2011 19:09'!crLog: aString	"Log the argument. Use self log: instead of Transcript cr; show: "		Transcript cr; show: aString.! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 5/23/2011 22:09'!log: aString	"Log the argument. Use self log: instead of Transcript show: "		Transcript show: aString.! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 11/7/2011 22:43'!crLog      self crTrace: self printString! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 5/27/2011 19:07'!logCrTab: aString	"Log the argument. Use self logCr: 'something' instead of Transcript show: 'something'  ; cr ; tab"		Transcript show: aString ; cr ; tab! !!Object methodsFor: 'logging-Deprecated' stamp: 'StephaneDucasse 5/23/2011 22:09'!logCr: aString	"Log the argument. Use self logCr: 'something' instead of Transcript show: 'something'  ; cr "		Transcript show: aString ; cr! !!Object methodsFor: '*UnifiedFFI-Legacy' stamp: 'EstebanLorenzano 1/4/2016 17:02'!nbCall: fnSpec options: callOptions	" you can override this method if you need to"	^ (self ffiCalloutIn: thisContext sender)		convention: self ffiCallingConvention;		options: callOptions;		function: fnSpec module: self ffiLibraryName! !!Object methodsFor: '*UnifiedFFI-Legacy' stamp: 'EstebanLorenzano 2/29/2016 14:06'!nbCall: fnSpec module: aModuleNameOrHandle options: callOptions	" you can override this method if you need to"	^ (self ffiCalloutIn: thisContext sender)		convention: self ffiCallingConvention;		options: callOptions;		function: fnSpec module: aModuleNameOrHandle! !!Object methodsFor: '*UnifiedFFI-Legacy' stamp: 'EstebanLorenzano 9/3/2015 15:04'!nbCall: fnSpec module: aModuleNameOrHandle	" you can override this method if you need to"	^ (self ffiCalloutIn: thisContext sender)		convention: self ffiCallingConvention;		function: fnSpec module: aModuleNameOrHandle! !!Object methodsFor: '*UnifiedFFI-Legacy' stamp: 'EstebanLorenzano 9/3/2015 15:04'!nbCall: fnSpec	" you can override this method if you need to"		^ (self ffiCalloutIn: thisContext sender)		convention: self ffiCallingConvention;		function: fnSpec module: self ffiLibraryName! !!Object methodsFor: 'asserting' stamp: 'MarcusDenker 10/23/2015 13:43'!assert: aBlock	"Throw an assertion error if aBlock does not evaluates to true.	We check for true explicitly to make the assertion fail for non booleans"		aBlock value == true ifFalse: [AssertionFailure signal: 'Assertion failed']! !!Object methodsFor: 'asserting' stamp: 'jannik.laval 5/2/2010 16:59'!assert: aBlock descriptionBlock: descriptionBlock	"Throw an assertion error if aBlock does not evaluate to true."		aBlock value ifFalse: [AssertionFailure signal: descriptionBlock value asString ]! !!Object methodsFor: 'asserting' stamp: 'CamilloBruni 5/27/2013 16:20'!assert: aBlock description: aStringOrBlock	"Throw an assertion error if aBlock does not evaluates to true."		aBlock value 		ifFalse: [ AssertionFailure signal: aStringOrBlock value ]! !!Object methodsFor: 'self evaluating' stamp: 'sd 7/31/2005 21:47'!isSelfEvaluating	^ self isLiteral! !!Object methodsFor: 'testing' stamp: 'rhi 8/14/2003 08:51'!isHeap	^ false! !!Object methodsFor: 'testing'!isNumber	"Overridden to return true in Number, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'sma 6/15/2000 15:48'!isString	"Overridden to return true in String, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'di 11/9/1998 09:38'!isFloat	"Overridden to return true in Float, natch"	^ false! !!Object methodsFor: 'testing'!isInteger	"Overridden to return true in Integer."	^ false! !!Object methodsFor: 'testing'!isText	^ false! !!Object methodsFor: 'testing' stamp: 'ar 8/17/1999 19:43'!isCollection	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"	^false! !!Object methodsFor: 'testing' stamp: 'nk 4/25/2002 08:04'!isMessageSend	^false! !!Object methodsFor: 'testing' stamp: 'ajh 1/21/2003 13:15'!isBlock	^ false! !!Object methodsFor: 'testing' stamp: 'gm 2/22/2003 12:56'!isMorphicModel	"Return true if the receiver is a morphic model"	^false! !!Object methodsFor: 'testing'!isColor	"Answer true if receiver is a Color. False by default."	^ false! !!Object methodsFor: 'testing' stamp: 'di 11/6/1998 08:04'!isPoint	"Overridden to return true in Point."	^ false! !!Object methodsFor: 'testing'!isMorph	^ false! !!Object methodsFor: 'testing' stamp: 'md 11/21/2003 12:14'!isCompiledMethod	^ false! !!Object methodsFor: 'testing' stamp: 'eem 5/23/2008 13:47'!isClosure	^false! !!Object methodsFor: 'testing' stamp: 'sw 1/12/98 18:09'!haltIfNil! !!Object methodsFor: 'testing' stamp: 'rhi 8/12/2003 09:52'!isInterval	^ false! !!Object methodsFor: 'testing'!notNil	"Coerces nil to false and everything else to true."	^true! !!Object methodsFor: 'testing' stamp: 'md 4/30/2003 15:30'!isSymbol	^ false ! !!Object methodsFor: 'testing' stamp: 'nk 4/17/2004 19:43'!isColorForm	^false! !!Object methodsFor: 'testing' stamp: 'md 10/2/2005 21:52'!isRectangle	^false! !!Object methodsFor: 'testing' stamp: 'ar 7/9/1999 18:18'!isBehavior	"Return true if the receiver is a behavior.	Note: Do not override in any class except behavior."	^false! !!Object methodsFor: 'testing' stamp: 'eem 5/8/2008 11:13'!isArray	^false! !!Object methodsFor: 'testing' stamp: 'yo 8/28/2002 13:41'!isCharacter	^ false.! !!Object methodsFor: 'testing' stamp: 'ar 12/23/1999 15:43'!isStream	"Return true if the receiver responds to the stream protocol"	^false! !!Object methodsFor: 'testing' stamp: 'ar 8/14/2001 23:19'!isVariableBinding	"Return true if I represent a literal variable binding"	^false	! !!Object methodsFor: 'testing' stamp: 'HenrikNergaard 5/15/2016 19:36'!isClassOrTrait	^ self isClass or: [ self isTrait ]! !!Object methodsFor: 'testing' stamp: 'len 1/13/98 21:18'!isFraction	"Answer true if the receiver is a Fraction."	^ false! !!Object methodsFor: 'testing' stamp: 'ar 10/30/2000 23:22'!isForm	^false! !!Object methodsFor: 'testing' stamp: 'MarcusDenker 10/17/2013 12:05'!isClass	^ false! !!Object methodsFor: 'testing' stamp: 'ar 9/13/2000 15:37'!isMorphicEvent	^false! !!Object methodsFor: 'testing' stamp: 'adrian-lienhard 6/21/2009 23:52'!isTrait	^false! !!Object methodsFor: 'testing' stamp: 'jam 3/9/2003 15:10'!isSystemWindow"answer whatever the receiver is a SystemWindow"	^ false! !!Object methodsFor: 'testing' stamp: 'MarcusDenker 4/9/2013 14:25'!isNotNil	"Coerces nil to false and everything else to true."	^true! !!Object methodsFor: 'testing' stamp: 'md 8/11/2005 16:45'!isDictionary	^false! !!Object methodsFor: 'testing' stamp: 'md 2/19/2006 11:24'!isMethodProperties	^false! !!Object methodsFor: 'testing' stamp: 'eem 11/26/2008 20:22'!isContext	^false! !!Object methodsFor: 'associating' stamp: 'MarcusDenker 10/4/2016 16:51'!-> anObject	"Answer an Association between self and anObject"	"the code of Association>>#key:value: is inline here for speed"	^Association basicNew key: self value: anObject! !!Object methodsFor: 'set implementation' stamp: 'Igor.Stasenko 11/13/2009 07:19'!enclosedSetElement	"The receiver is included into a set as an element. 	Since some objects require wrappers (see SetElement) to be able to be included into a Set,	a set sends this message to its element to make sure it getting real object,	instead of its wrapper.	Only SetElement instance or its subclasses allowed to answer something different than receiver itself"	! !!Object methodsFor: 'reflective operations'!someObject	"Primitive. Answer the first object in the enumeration of all	 objects."	<primitive: 138>	self primitiveFailed.! !!Object methodsFor: 'reflective operations' stamp: 'ar 3/2/2001 01:34'!primitiveChangeClassTo: anObject	"Primitive. Change the class of the receiver into the class of the argument given that the format of the receiver matches the format of the argument's class. Fail if receiver or argument are SmallIntegers, or the receiver is an instance of a compact class and the argument isn't, or when the argument's class is compact and the receiver isn't, or when the format of the receiver is different from the format of the argument's class, or when the arguments class is fixed and the receiver's size differs from the size that an instance of the argument's class should have.	Note: The primitive will fail in most cases that you think might work. This is mostly because of a) the difference between compact and non-compact classes, and b) because of differences in the format. As an example, '(Array new: 3) primitiveChangeClassTo: Morph basicNew' would fail for three of the reasons mentioned above. Array is compact, Morph is not (failure #1). Array is variable and Morph is fixed (different format - failure #2). Morph is a fixed-field-only object and the array is too short (failure #3).	The facility is really provided for certain, very specific applications (mostly related to classes changing shape) and not for casual use."	<primitive: 115>	self primitiveFailed! !!Object methodsFor: 'reflective operations' stamp: 'di 1/9/1999 15:19'!becomeForward: otherObject 	"Primitive. All variables in the entire system that used to point	to the receiver now point to the argument.	Fails if either argument is a SmallInteger."	(Array with: self)		elementsForwardIdentityTo:			(Array with: otherObject)! !!Object methodsFor: 'reflective operations' stamp: 'CamilloBruni 8/1/2012 16:26'!doesNotUnderstand: aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message (typically sent from the machine when a message is sent to the receiver and no method is defined for that selector)."	"Testing: (3 activeProcess)"			| exception resumeValue |	(exception := MessageNotUnderstood new)		message: aMessage;		receiver: self.	resumeValue := exception signal.	^exception reachedDefaultHandler		ifTrue: [aMessage sentTo: self]		ifFalse: [resumeValue]! !!Object methodsFor: 'reflective operations' stamp: 'MartinDias 7/1/2013 14:55'!becomeForward: otherObject copyHash: copyHash	"Primitive. All variables in the entire system that used to point to the receiver now point to the argument.	If copyHash is true, the argument's identity hash bits will be set to those of the receiver.	Fails if either argument is a SmallInteger."	(Array with: self)		elementsForwardIdentityTo: (Array with: otherObject)		copyHash: copyHash! !!Object methodsFor: '*GT-SUnitDebugger' stamp: 'AndreiChis 12/28/2015 20:22'!gtDebuggerSUnitPrint	"I return a textual representation of the object that is used by the SUnit debugger to compare objects using a textual diff."		^ self printString! !!Object methodsFor: 'write barrier' stamp: 'ClementBera 4/21/2016 13:56'!beWritableObject	"If the VM supports read-only objects it will not write to read-only objects.	 An attempt to write to an instance variable of a read-only object will	 cause the VM to send attemptToAssign:withIndex: to the read-only object.	 An attempt to modify a read-only object in a primitive will cause the	 primitive to fail with a #'no modification' error code.	 Set the read-only flag of the receiver to false and answer the previous vaue of the flag."	^self setIsReadOnlyObject: false! !!Object methodsFor: 'write barrier' stamp: 'ClementBera 4/21/2016 13:56'!beReadOnlyObject	"If the VM supports read-only objects it will not write to read-only objects.	 An attempt to write to an instance variable of a read-only object will	 cause the VM to send attemptToAssign:withIndex: to the read-only object.	 An attempt to modify a read-only object in a primitive will cause the	 primitive to fail with a #'no modification' error code.	 Set the read-only flag of the receiver to true and answer the previous vaue of the flag."	^self setIsReadOnlyObject: true! !!Object methodsFor: 'write barrier' stamp: 'ClementBera 4/21/2016 13:55'!isReadOnlyObject	"Answer if the receiver is read-only.	 If the VM supports read-only objects it will not write to read-only objects.	 An attempt to write to an instance variable of a read-only object will	 cause the VM to send attemptToAssign:withIndex: to the read-only object.	 An attempt to modify a read-only object in a primitive will cause the	 primitive to fail with a #'no modification' error code."	<primitive: 163 error: ec>	^self primitiveFailed! !!Object methodsFor: 'write barrier' stamp: 'ClementBera 4/21/2016 13:55'!setIsReadOnlyObject: aBoolean	"If the VM supports read-only objects it will not write to read-only objects.	 An attempt to write to an instance variable of a read-only object will	 cause the VM to send attemptToAssign:withIndex: to the read-only object.	 An attempt to modify a read-only object in a primitive will cause the	 primitive to fail with a #'no modification' error code.	 This primitive sets the read-only flag of the receiver to the given	 value and answers the previous vaue of the flag.	 Note: Some objects can't be read-only, currently contexts and objects related	 to process scheduling (Processor, Process instances, Semaphore instances, ...)"	<primitive: 164 error: ec>	^self primitiveFailed	! !!Object methodsFor: 'write barrier' stamp: 'DenisKudryashov 1/27/2017 15:23'!attemptToAssign: value withIndex: index 	"Called by the VM when assigning an instance variable of an immutable object.	Upon return, executing will resume *after* the inst var assignment. If the inst var mutation has to be 	performed, do it manually here in the call back with instVarAt:put:.	This method has to return *no* value by jumping to the context's sender"		(ModificationForbidden for: self atInstVar: index with: value)	signal.	thisContext sender jump	"CAN'T REACH"! !!Object methodsFor: '*Shout-Parsing' stamp: 'SeanDeNigris 6/22/2012 18:24'!shoutParser: anSHParserST80	"Tools can define this method to customize the parser"! !!Object methodsFor: '*Glamour-Morphic-Brick' stamp: 'AliakseiSyrel 1/23/2015 21:46'!phlowValue: anObject withEnoughArguments: aCollection	^ self! !!Object methodsFor: '*Glamour-Morphic-Brick' stamp: 'AliakseiSyrel 2/26/2015 23:14'!brickAlert	GLMAlertBrick alert: self! !!Object methodsFor: '*Glamour-Morphic-Brick' stamp: 'AliakseiSyrel 1/20/2015 17:22'!brickValue: aBrick	^ self! !!Object methodsFor: '*Glamour-Morphic-Brick' stamp: 'AliakseiSyrel 1/11/2015 15:19'!asBrick	^ GLMMorphBrick on: self asMorph! !!Object methodsFor: '*Glamour-Morphic-Brick' stamp: 'AliakseiSyrel 1/22/2015 21:13'!phlowValue: anObject	^ self! !!Object methodsFor: '*Glamour-Morphic-Brick' stamp: 'AliakseiSyrel 1/22/2015 21:33'!phlowValue: anObject value: otherObject	^ self! !!Object methodsFor: '*Glamour-Morphic-Brick' stamp: 'AliakseiSyrel 2/17/2015 12:33'!brickValue: anObject withEnoughArguments: aCollection	^ self! !!Object methodsFor: 'error handling' stamp: 'md 8/2/2005 22:17'!error	"Throw a generic Error exception."	^self error: 'Error!!'.! !!Object methodsFor: 'error handling' stamp: 'SvenVanCaekenberghe 4/20/2011 13:25'!subclassResponsibility	"This message sets up a framework for the behavior of the class' subclasses.	Announce that the subclass should have implemented this message."	SubclassResponsibility signalFor: thisContext sender selector! !!Object methodsFor: 'error handling' stamp: 'md 1/20/2006 16:24'!handles: exception	"This method exists in case a non exception class is the first arg in an on:do: (for instance using a exception class that is not loaded). We prefer this to raising an error during error handling itself. Also, semantically it makes sense that the exception handler is not active if its exception class is not loaded"	^ false! !!Object methodsFor: 'error handling' stamp: 'al 12/16/2003 16:16'!traitConflict	self error: 'A class or trait does not properly resolve a conflict between multiple traits it uses.'! !!Object methodsFor: 'error handling'!notify: aString at: location	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed. Subclasses can	override this and insert an error message at location within aString."	self notify: aString	"nil notify: 'confirmation message' at: 12"! !!Object methodsFor: 'error handling' stamp: 'SvenVanCaekenberghe 4/20/2011 13:26'!shouldBeImplemented	"Announce that this message should be implemented"	ShouldBeImplemented signalFor: thisContext sender selector! !!Object methodsFor: 'error handling' stamp: 'tfei 4/12/1999 12:55'!error: aString 	"Throw a generic Error exception."	^Error new signal: aString! !!Object methodsFor: 'error handling' stamp: 'al 9/16/2005 14:12'!requirement	self error: 'Implicitly required method'! !!Object methodsFor: 'error handling' stamp: 'PabloHerrero 6/7/2014 03:15'!explicitRequirement	"If one of the superclasses can perform the selector, we execute the method of that class, otherwise, the explicit requirement error is thrown"	| originalMethod originalArguments errorBlock originalReceiver callingContext originalSelector |	errorBlock := [ ^ self error: 'Explicitly required method' ].	callingContext := thisContext sender.	originalMethod := callingContext method.	originalMethod isFromTrait		ifFalse: errorBlock.			originalReceiver := callingContext receiver.	originalSelector := originalMethod selector.	originalArguments := callingContext arguments.		originalReceiver class superclass		withAllSuperclassesDo: [ :superClass | 			superClass				compiledMethodAt: originalSelector				ifPresent: [ :method | 					(method isProvided or: [ method isFromTrait not ])						ifTrue: [ 							callingContext return: (method valueWithReceiver: originalReceiver arguments: originalArguments) ] ]				ifAbsent: [  ] ].	errorBlock value! !!Object methodsFor: 'error handling' stamp: 'SvenVanCaekenberghe 4/20/2011 13:25'!shouldNotImplement	"Announce that, although the receiver inherits this message, 	it should not implement it."	ShouldNotImplement signalFor: thisContext sender selector! !!Object methodsFor: 'error handling' stamp: 'stephane.ducasse 6/1/2009 13:51'!notify: aString 	"Create and schedule a Notifier with the argument as the message in 	order to request confirmation before a process can proceed."	Warning signal: aString! !!Object methodsFor: 'error handling' stamp: 'MarcusDenker 5/24/2012 10:37'!notYetImplemented	"Announce that this message is not yet implemented"	NotYetImplemented signalFor: thisContext sender selector! !!Object methodsFor: '*System-Finalization' stamp: 'GuillermoPolito 6/3/2016 19:06'!mourn	"Sent by the new Finalization mechanism.	All weak objects (instances of weak classes) and Ephemerons may be mourned if they point to an object that needs to be collected.		This default implementation does nothing. To override in specific subclasses."! !!Object methodsFor: 'model - updating'!okToChange	"Allows a controller to ask this of any model"	^ true! !!Object methodsFor: 'model - updating' stamp: 'MarianoMartinezPeck 8/24/2012 15:28'!windowIsClosing	"This message is used to inform a models that its window is closing. Most models do nothing, but some, such as the Debugger, must do some cleanup. Note that this mechanism must be used with care by models that support multiple views, since one view may be closed while others left open."! !!Object methodsFor: '*Fuel' stamp: 'MartinDias 3/29/2012 03:05'!fuelAccept: aGeneralMapper	"Be careful because the order is important. For example, weak are also variable, but we need that weak objects send #visitWeakObject: and not #visitVariableObject: "	self class isFixed		ifTrue: [ ^ aGeneralMapper visitFixedObject: self ].	self class isWeak		ifTrue: [ ^ aGeneralMapper visitWeakObject: self ].	self class isPointers		ifTrue: [ ^ aGeneralMapper visitVariableObject: self ].	self class isBytes		ifTrue: [ ^ aGeneralMapper visitBytesObject: self ].	self class isWords		ifTrue: [	^ aGeneralMapper visitWordsObject: self ].	self error: 'Something is wrong!!'! !!Object methodsFor: '*Fuel' stamp: 'CamilloBruni 6/14/2013 09:59'!serializeToFileNamed: aFilename	^ FLSerializer serialize: self toFileNamed: aFilename! !!Object methodsFor: '*Fuel' stamp: 'MartinDias 8/27/2011 19:03'!fuelAfterMaterialization	"Materialization process will send this message after materializing instances of my class"! !!Object methodsFor: '*Fuel' stamp: 'MaxLeske 5/3/2013 15:18'!fuelReplacement	^ self! !!Object methodsFor: '*System-Settings-Browser' stamp: 'alain.plantec 3/19/2009 09:50'!settingStoreOn: aStream	^ self storeOn: aStream! !!Object methodsFor: '*System-Settings-Browser' stamp: 'alain.plantec 3/24/2009 23:21'!settingFixedDomainValueNodeFrom: aSettingNode 	^ aSettingNode fixedDomainValueNodeForObject: self! !!Object methodsFor: '*Collections-Abstract-splitjoin' stamp: 'onierstrasz 4/12/2009 19:58'!appendTo: aCollection	"double dispatch for join:"	^ aCollection addLast: self! !!Object methodsFor: '*Collections-Abstract-splitjoin' stamp: 'CamilloBruni 1/19/2013 12:38'!split: aSequenceableCollection do: aBlock	"optimized version for single delimiters:	Example:		$/ split: '/foo/bar' indicesDo: [ :item | ]"	self split: aSequenceableCollection indicesDo: [ :start :end | 		aBlock value: (aSequenceableCollection copyFrom: start to: end) ]! !!Object methodsFor: '*Collections-Abstract-splitjoin' stamp: 'CamilloBruni 1/19/2013 12:38'!split: aSequenceableCollection indicesDo: aBlock	"optimized version for single delimiters:	Example:		$/ split: '/foo/bar' indicesDo: [ :start :end | ]"			|  position oldPosition |		position := 1.	oldPosition := position.		position := aSequenceableCollection indexOf: self startingAt: position.	[ position > 0 ] whileTrue: [		aBlock value: oldPosition value: position - 1.		position := position + 1.		oldPosition := position.		position := aSequenceableCollection indexOf: self startingAt: position.	].	aBlock value: oldPosition value: aSequenceableCollection size.! !!Object methodsFor: '*Collections-Abstract-splitjoin' stamp: 'onierstrasz 4/12/2009 19:58'!joinTo: stream	"double dispatch for join:"	^ stream nextPut: self! !!Object methodsFor: '*Collections-Abstract-splitjoin' stamp: 'CamilloBruni 1/19/2013 12:38'!split: aSequenceableCollection	"optimized version for single delimiters:	Example:		$/ split: '/foo/bar'"			| result position oldPosition |		result := OrderedCollection new: (aSequenceableCollection size / 2) asInteger.	self split: aSequenceableCollection do: [ :item |		result add: item ].	^ result! !!Object methodsFor: '*Collections-Abstract-splitjoin' stamp: 'onierstrasz 4/10/2009 22:50'!join: aSequenceableCollection	^ (Array with: self) join: aSequenceableCollection! !!Object methodsFor: 'introspection' stamp: 'MarcusDenker 6/26/2014 16:23'!writeSlot: aSlot value: anObject	^aSlot write: anObject to: self! !!Object methodsFor: 'introspection' stamp: 'eem 5/14/2008 13:20'!instVarNamed: aString	"Return the value of the instance variable in me with that name.  Slow and unclean, but very useful. "	^ self instVarAt: (self class						instVarIndexFor: aString asString						ifAbsent: [self error: 'no such inst var'])! !!Object methodsFor: 'introspection' stamp: 'MarcusDenker 6/26/2014 16:27'!writeSlotNamed: aName value: anObject	^(self class slotNamed: aName) write: anObject to: self! !!Object methodsFor: 'introspection' stamp: 'MarcusDenker 6/26/2014 16:19'!readSlot: aSlot	^aSlot read: self! !!Object methodsFor: 'introspection' stamp: 'eem 12/25/2014 18:01'!instVarAt: index put: anObject	"Primitive. Store a value into a fixed variable in an object. The numbering of the	 variables corresponds to the named instance variables, followed by the indexed	 instance variables. Fail if the index is not an Integer or is not the index of a fixed	 variable. Essential. See Object documentation whatIsAPrimitive."	<primitive: 174 error: ec>	self primitiveFailed! !!Object methodsFor: 'introspection' stamp: 'eem 5/14/2008 13:20'!instVarNamed: aString put: aValue	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful. "	^self		instVarAt: (self class						instVarIndexFor: aString asString						ifAbsent: [self error: 'no such inst var'])		put: aValue! !!Object methodsFor: 'introspection' stamp: 'sw 10/16/2000 10:59'!className	"Answer a string characterizing the receiver's class, for use in list views for example"	^ self class name asString! !!Object methodsFor: 'introspection' stamp: 'MarcusDenker 6/26/2014 16:21'!readSlotNamed: aName	^self readSlot: (self class slotNamed: aName)! !!Object methodsFor: 'introspection' stamp: 'eem 12/25/2014 18:01'!instVarAt: index	"Primitive. Answer a fixed variable in an object. The numbering of the variables	 corresponds to the named instance variables, followed by the indexed instance	 variables. Fail if the index is not an Integer or is not the index of a fixed variable.	 Essential. See Object documentation whatIsAPrimitive."	<primitive: 173 error: ec>	self primitiveFailed! !!Object methodsFor: 'private' stamp: 'yo 6/29/2004 11:37'!errorNotIndexable	"Create an error notification that the receiver is not indexable."	self error: ('Instances of {1} are not indexable' translated format: {self class name})! !!Object methodsFor: 'private'!errorImproperStore	"Create an error notification that an improper store was attempted."	self error: 'Improper store into indexable object'! !!Object methodsFor: 'private'!storeAt: offset inTempFrame: aContext	"This message had to get sent to an expression already on the stack	as a Block argument being accessed by the debugger.	Just re-route it to the temp frame."	^ aContext tempAt: offset put: self! !!Object methodsFor: 'private' stamp: 'SvenVanCaekenberghe 4/21/2011 13:00'!errorSubscriptBounds: index 	"Create an error notification that an improper integer was used as an index."	SubscriptOutOfBounds signalFor: index! !!Object methodsFor: 'private' stamp: 'eem 5/9/2008 09:04'!species	"Answer the preferred class for reconstructing the receiver.  For example, 	collections create new collections whenever enumeration messages such as 	collect: or select: are invoked.  The new kind of collection is determined by 	the species of the original collection.  Species and class are not always the 	same.  For example, the species of Interval is Array."	<primitive: 111>	^self class! !!Object methodsFor: 'private'!errorNonIntegerIndex	"Create an error notification that an improper object was used as an index."	self error: 'only integers should be used as indices'! !!Object methodsFor: 'tracing' stamp: 'StephaneDucasse 11/6/2011 23:56'!crTrace      self crTrace: self printString! !!Object methodsFor: 'tracing' stamp: 'StephaneDucasse 11/6/2011 23:56'!traceCr: aString	"Log the argument. Use self traceCr: 'something' instead of Transcript show: 'something'  ; cr "		Transcript show: aString ; cr! !!Object methodsFor: 'tracing' stamp: 'StephaneDucasse 11/6/2011 23:58'!trace      self trace: self printString! !!Object methodsFor: 'tracing' stamp: 'StephaneDucasse 11/6/2011 23:55'!trace: aString	"Log the argument. Use self trace: instead of Transcript show: "		Transcript show: aString.! !!Object methodsFor: 'tracing' stamp: 'StephaneDucasse 11/6/2011 23:57'!crTrace: aString	"Log the argument. Use self crTrace: instead of Transcript cr; show: "		Transcript cr; show: aString.! !!Object methodsFor: 'tracing' stamp: 'StephaneDucasse 11/6/2011 23:56'!traceCr      self traceCr: self printString! !!Object methodsFor: 'displaying' stamp: 'StephaneDucasse 8/21/2015 20:07'!displayString	"While printString is about to give a detailled information about an object, displayString is a message that should return a short string-based representation to be used by list and related UI frameworks. By default, simply return printString."	"asString should not be implemented in Object, and kept for conversion between strings, symbols, text and characters."		^ self printString! !!Object methodsFor: '*GT-Debugger-UI' stamp: 'AndreiChis 1/10/2016 18:46'!gtConstructDebuggerInspectorIn: composite for: aDebugger		^ composite custom: (GTDebuggerInspector new 		debugger: aDebugger;		startOn: self)! !!Object methodsFor: '*GT-Debugger-UI' stamp: 'TudorGirba 1/17/2016 22:40'!gtDebuggerRawIn: composite		(GTObjectVariablesBrowser new variablesIn: composite)		title: 'Raw';		send: #value! !!Object methodsFor: '*GT-Debugger-UI' stamp: 'AndreiChis 1/15/2016 17:36'!gtDebuggerEvaluatorIn: composite		(GTObjectVariablesBrowser new evaluatorIn: composite)		title: 'Evaluator'! !!Object methodsFor: 'process termination handling' stamp: 'DenisKudryashov 6/13/2016 15:24'!handleProcessTerminationOfWaitingContext: suspendedContext	^suspendedContext! !!Object methodsFor: '*Ring-Core-Kernel' stamp: 'StephaneDucasse 7/16/2011 22:53'!isRingObject	^false! !!Object methodsFor: '*Morphic-Widgets-Basic'!wantsDroppedMorph: aMorph event: anEvent inMorph: destinationLM 	^false ! !!Object methodsFor: '*Morphic-Widgets-Basic' stamp: 'panda 4/28/2000 16:11'!dragTransferType	^nil! !!Object methodsFor: '*Morphic-Widgets-Basic'!dragTransferTypeForMorph: dragSource 	^nil! !!Object methodsFor: '*Morphic-Widgets-Basic'!dragPassengerFor: item inMorph: dragSource 	^item! !!Object methodsFor: '*Morphic-Widgets-Basic'!acceptDroppingMorph: transferMorph event: evt inMorph: dstListMorph 		^false.! !!Object methodsFor: '*Spec-Core' stamp: 'ChristopheDemarey 11/20/2013 14:38'!isTreeNodeModel	^ false! !!Object methodsFor: '*Spec-Core' stamp: 'BenjaminVanRyseghem 6/18/2012 05:26'!isSpecLayout	^ false! !!Object methodsFor: '*Spec-Core' stamp: 'BenjaminVanRyseghem 11/26/2013 17:18'!isSpecAdapter	^ false! !!Object methodsFor: '*Spec-Core' stamp: 'webwarrior 7/18/2014 13:59'!isSpecContainer	^ false! !!Object methodsFor: '*Spec-Core' stamp: 'BenjaminVanRyseghem 10/1/2013 13:46'!asWidget	^ self! !!Object methodsFor: 'message performing' stamp: 'EstebanLorenzano 6/28/2016 11:13'!perform: aSymbol with: firstObject with: secondObject with: thirdObject with: fourthObject	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not four.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: (Array with: firstObject with: secondObject with: thirdObject with: fourthObject)! !!Object methodsFor: 'message performing' stamp: 'st 11/5/2004 16:19'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ (self respondsTo: selector) ifTrue: [self perform: selector] ifFalse: [otherTarget perform: selector]! !!Object methodsFor: 'message performing' stamp: 'MarcusDenker 7/23/2014 22:37'!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol		withArguments: {firstObject . secondObject . thirdObject}! !!Object methodsFor: 'message performing' stamp: 'ClementBera 4/21/2013 14:41'!perform: selector withArguments: argArray inSuperclass: lookupClass	"NOTE:  This is just like perform:withArguments:, except that	the message lookup process begins, not with the receivers's class,	but with the supplied superclass instead.  It will fail if lookupClass	cannot be found among the receiver's superclasses.	Primitive. Essential. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageInSuperclass:>	<primitive: 100>	(selector isSymbol)		ifFalse: [^ self error: 'selector argument must be a Symbol'].	(selector numArgs = argArray size)		ifFalse: [^ self error: 'incorrect number of arguments'].	(self class == lookupClass or: [self class inheritsFrom: lookupClass])		ifFalse: [^ self error: 'lookupClass is not in my inheritance chain'].	self primitiveFailed! !!Object methodsFor: 'message performing' stamp: 'ClementBera 4/21/2013 14:49'!perform: selector withArguments: argArray 	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Fail if the number of arguments expected by the selector 	does not match the size of argArray.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWithArgs:>	<primitive: 84>	^ self perform: selector withArguments: argArray inSuperclass: self class! !!Object methodsFor: 'message performing' stamp: 'ClementBera 4/21/2013 14:53'!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Object methodsFor: 'message performing' stamp: 'ClementBera 4/21/2013 14:53'!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Object methodsFor: 'message performing' stamp: 'nk 4/11/2002 14:13'!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!Object methodsFor: 'message performing' stamp: 'ClementBera 4/21/2013 14:53'!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."		<reflective: #object:performMessageWith:>	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Object methodsFor: '*Epicea' stamp: 'MartinDias 9/17/2014 11:16'!isEpEvent		^ false! !!Object methodsFor: '*qualityAssistant' stamp: 'YuriyTymchuk 12/8/2016 10:47'!qaTextSegmentsDo: aBlock		self externalProperties do: [ :eprop |		| segment interval |		interval := eprop sourceAnchor providesInterval			ifTrue:  [ eprop sourceAnchor interval ]			ifFalse: [ 0 to: -1 ]. 				segment := QARubTextSegmentMorph			from: interval first			to: interval last + 1.		segment			label: eprop title;			icon: eprop icon;			color: eprop color;			critique: eprop;			entity: self.				aBlock value: segment ].! !!Object methodsFor: '*qualityAssistant' stamp: 'YuriyTymchuk 12/8/2016 10:45'!annotateRubricText: anAnnotatableTextModel	| conf |	conf := RubConfigurationChange new.		conf configurationBlock: [ :text |		self qaTextSegmentsDo: [ :segment | 			text addSegment: segment ] ].	anAnnotatableTextModel announce: conf! !!Object methodsFor: '*Text-Core' stamp: 'MarcusDenker 7/20/2012 14:59'!asStringOrText	"Answer a string that represents the receiver."	^ self asString ! !!Object methodsFor: 'evaluating' stamp: 'ajh 1/21/2003 12:59'!in: aBlock	"Evaluate the given block with the receiver as its argument."	^ aBlock value: self! !!Object methodsFor: 'evaluating' stamp: 'reThink 2/18/2001 15:23'!valueWithArguments: aSequenceOfArguments	^self! !!Object methodsFor: 'evaluating' stamp: 'MarianoMartinezPeck 8/24/2012 15:58'!value	^self! !!Object methodsFor: '*10Pines-C17-1' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !!Object methodsFor: '*MenuRegistration-Core' stamp: 'SeanDeNigris 6/16/2013 13:38'!fallbackMenuOn: aMenuMorph	"When pragma menu building goes wrong, a fallback menu is created. To add custom items to that menu, override me in subclasses. See WorldState>>#fallbackMenuOn: for an example"! !!Object methodsFor: 'binding'!bindingOf: aString	^nil! !!Object methodsFor: 'binding' stamp: 'MarcusDenker 11/12/2015 13:43'!hasBindingOf: aString	^false! !!Object methodsFor: 'model - stepping' stamp: 'sw 10/20/1999 14:52'!stepAt: millisecondClockValue in: aWindow	^ self stepIn: aWindow! !!Object methodsFor: 'model - stepping' stamp: 'sw 10/19/1999 08:21'!stepTime		^ 1000 "milliseconds -- default backstop for objects serving as models of system windows"! !!Object methodsFor: 'model - stepping' stamp: 'sw 10/19/1999 08:16'!stepIn: aWindow	^ self step! !!Object methodsFor: 'model - stepping' stamp: 'sw 10/19/1999 08:22'!stepTimeIn: aSystemWindow		^ 1000 "milliseconds -- default backstop for objects serving as models of system windows"! !!Object methodsFor: 'model - stepping' stamp: 'sw 10/19/1999 08:26'!wantsStepsIn: aSystemWindow		^ self wantsSteps! !!Object methodsFor: 'model - stepping' stamp: 'di 1/8/1999 15:04'!wantsSteps	"Overridden by morphic classes whose instances want to be stepped,	or by model classes who want their morphic views to be stepped."	^ false! !!Object methodsFor: 'system primitives' stamp: 'eem 12/25/2014 15:13'!setPinned: aBoolean	"The VM's garbage collector routinely moves objects as it reclaims and compacts	 memory. But it can also pin an object so that it will not be moved, which can make	 it easier to pass objects out through the FFI.  Objects are unpinnned when created.	 This primitive either pins or unpins an object, and answers if it was already pinned."	<primitive: 184 error: ec>	^self primitiveFailed! !!Object methodsFor: 'system primitives' stamp: 'eem 12/25/2014 15:04'!isPinned	"Answer if the receiver is pinned.  The VM's garbage collector routinely moves	 objects as it reclaims and compacts memory.  But it can also pin an object so	 that it will not be moved, which can make it easier to pass objects out through	 the FFI."	<primitive: 183 error: ec>	^self primitiveFailed! !!Object methodsFor: 'system primitives' stamp: 'eem 12/25/2014 15:13'!pin	"The VM's garbage collector routinely moves objects as it reclaims and compacts	 memory. But it can also pin an object so that it will not be moved, which can make	 it easier to pass objects out through the FFI.  Objects are unpinnned when created.	 This method ensures an object is pinned, and answers whether it was already pinned."	^self setPinned: true! !!Object methodsFor: 'system primitives' stamp: 'eem 12/25/2014 15:12'!unpin	"The VM's garbage collector routinely moves objects as it reclaims and compacts	 memory. But it can also pin an object so that it will not be moved, which can make	 it easier to pass objects out through the FFI.  Objects are unpinnned when created.	 This method ensures an object is unpinned, and answers whether it was pinned."	^self setPinned: false! !!Object methodsFor: '*Glamour-Helpers' stamp: ' 4/5/09 22:18'!renderGlamorouslyOn: aRenderer 	 	^aRenderer renderObject: self! !!Object methodsFor: '*Rubric' stamp: 'AlainPlantec 4/18/2013 18:33'!unplug! !!Object methodsFor: '*GT-Spotter' stamp: 'AutoDeprecationRefactoring 7/13/2016 09:15'!spotterProcessorsFor: aSpotterStep pragma: aPragma	" if there is a problem with the definition of one or more processors, let the other processors continue to work "	[ | processorsSize addedProcessorsSize |	"To allow nice arrangement of processor within UI we need to assign to		each processor its spotter order. Because it is possible		to define multiple (or none) processors using pragma		we need to detect how many new processors were added"	processorsSize := aSpotterStep processors size.	self perform: aPragma methodSelector with: aSpotterStep.	addedProcessorsSize := aSpotterStep processors size - processorsSize.	"assign spotter order for newly added ones"	(aSpotterStep processors last: addedProcessorsSize)		do: [ :processor | processor order: (aPragma argumentAt: 1) ] ]		on: Error		do: [ :exception | 			aSpotterStep exceptionHandler				handleException: exception				do: [ ('[Spotter] Exception while collecting processors for <'						, self class name , '>: ' , exception asString) logCr ] ]! !!Object methodsFor: '*GT-Spotter' stamp: 'TudorGirba 11/26/2014 14:35'!asSpotterProcessorLink	^ GTSpotterProcessorLink value: self! !!Object methodsFor: '*GT-Spotter' stamp: 'StefanReichhart 3/23/2015 18:27'!spotterActDefault: aStep	aStep exit.	self spotterActDefault! !!Object methodsFor: '*GT-Spotter' stamp: 'AndreiChis 9/24/2015 18:14'!spotterProcessorsFor: aSpotterStep	"This is a utility method that collects all extensions (processors) for the current object.	By default, it simply looks for the #spotterOrder: pragma.	The step can decice whether or not an extension should be enabled.	The step can also configure each extension (e.g. override any property)"		^ (((Pragma 		allNamed: #spotterOrder:		from: self class 		to: Object)			select: [:pragma | aSpotterStep processorsFilter shouldEnableProcessorsCreateBy: pragma method])			sort: [ :first :second | (first argumentAt: 1) < (second argumentAt: 1) ])			do: [ :pragma ||currentSize|				currentSize := aSpotterStep processors size.				self spotterProcessorsFor: aSpotterStep pragma: pragma.				aSpotterStep "configure the new processors if required"					configureProcessorsStartingAt: currentSize+1 					with: (aSpotterStep processorsFilter configurationBlockForProcessorsCreatedBy: pragma method)]! !!Object methodsFor: '*GT-Spotter' stamp: 'StefanReichhart 2/24/2015 14:51'!gtFilter	^ GTFilterBlock gtFilter		! !!Object methodsFor: '*GT-Spotter' stamp: 'TudorGirba 11/18/2014 23:22'!spotterActDefault	^ self inspect! !!Object methodsFor: '*GT-Spotter' stamp: 'AutoDeprecationRefactoring 7/13/2016 09:24'!spotterPreviewIn: aComposite inContext: aSpotter	| pragmas |	pragmas := Pragma		allNamed: #spotterPreview:		from: self class		to: Object		sortedUsing: [ :x :y | (x argumentAt: 1) < (y argumentAt: 1) ].	"We iterate through all pragmas and execute the corresponding methods	to ensure that all possible previews are taken into account.	Even though at this moment we only display one preview, we still have to go through	all pragmas because it can happen that the method has a guarding if and thus, the actual	preview would not be triggered."	pragmas		do: [ :eachPragma | 			(eachPragma methodSelector findTokens: $:) size = 1				ifTrue: [ self perform: eachPragma methodSelector with: aComposite ].			(eachPragma methodSelector findTokens: $:) size = 2				ifTrue: [ self perform: eachPragma selector with: aComposite with: aSpotter ].			aComposite hasSubbricks				ifTrue: [ ^ self ] ]! !!Object methodsFor: '*GT-Spotter' stamp: 'TudorGirba 11/26/2014 14:35'!asSpotterCandidateLink	^ GTSpotterCandidateLink value: self! !!Object methodsFor: '*GT-Spotter' stamp: 'StefanReichhart 3/22/2015 16:58'!gtListFilter	^ GTFilterSubstring new! !!Object methodsFor: '*GT-Spotter' stamp: 'StefanReichhart 3/20/2015 11:48'!hasDynamicItems	^ false! !!Object methodsFor: '*GT-Spotter' stamp: 'AndreiChis 2/12/2017 14:53'!spotterPreviewRawIn: aComposite	<spotterPreview: 40>	aComposite table		title: [ self gtDisplayString ];		display: [ :anObject | (anObject gtInspectorVariableValuePairs asSortedCollection asOrderedCollection yourself) addFirst: 'self' -> anObject; yourself ];		column: 'Variable'			evaluated: [:assoc |	GTObjectPrinter asNonTruncatedTextFrom: assoc key ]			styled: [ :aBrick | aBrick textPosition: #rightCenter; margin: #(0 15 0 0); textColor: aComposite themer textLightColor; height: 30 ];		column: 'Value'			evaluated: [:assoc | GTObjectPrinter asTruncatedTextFrom: assoc value ]			styled: [ :aBrick | aBrick margin: #(0 0 0 15); height: 30 ];		entity: self.			self flag: 'move "entity: self" somewhere else, maybe'! !!Object methodsFor: '*GT-Spotter' stamp: 'StefanReichhart 3/20/2015 11:29'!gtIterator	^ Error signal: 'This is not a spotter iterator'! !!Object methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 8/10/2015 15:58'!ffiCallout	^ FFICalloutAPI calloutAPIClass inContext: thisContext sender! !!Object methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 2/9/2016 15:14'!pointer	"Answers a pointer to me (see overrides for implementations)"	self error: 'You cannot get a pointer to me.'! !!Object methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 8/10/2015 15:58'!ffiCalloutIn: aContext	^ FFICalloutAPI calloutAPIClass inContext: aContext! !!Object methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 8/10/2015 15:52'!ffiCall: fnSpec module: aModuleName options: callOptions	^ (self ffiCalloutIn: thisContext sender)		convention: self ffiCallingConvention;		options: callOptions;		function: fnSpec module: aModuleName ! !!Object methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 8/10/2015 16:04'!ffiCall: fnSpec	^ (self ffiCalloutIn: thisContext sender)		convention: self ffiCallingConvention;		function: fnSpec module: self ffiLibraryName! !!Object methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 3/22/2016 16:17'!packToArity: arity	"This will answer a pointer to this object. 	 It is like doing ==var ptr=&aVariable== in C (up to arity). 		 In general, arity>1 will not work because then object has to be copied to 	 heap, but my overrides will handle this case"	| rolledPointer |			rolledPointer := self.	1 to: arity do: [ :index | rolledPointer := rolledPointer pointer ].	^ rolledPointer! !!Object methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 8/10/2015 15:43'!ffiLibraryName	self flag: 'HACK: avoid direct subclassResponsibility to not break RB test cases..'.	^ SubclassResponsibility signalFor: thisContext selector! !!Object methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 8/10/2015 15:52'!ffiCall: fnSpec module: aModuleName	^ (self ffiCalloutIn: thisContext sender)		convention: self ffiCallingConvention;		function: fnSpec module: aModuleName ! !!Object methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 8/13/2015 16:03'!isExternalType	^ false! !!Object methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 8/10/2015 15:52'!ffiCall: fnSpec options: callOptions	^ (self ffiCalloutIn: thisContext sender)		convention: self ffiCallingConvention;		options: callOptions;		function: fnSpec module: self ffiLibraryName! !!Object methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 2/29/2016 13:51'!ffiCallingConvention	^ OSPlatform current ffiCallingConvention! !!Object methodsFor: '*GT-Inspector' stamp: 'TudorGirba 12/28/2013 21:59'!gtDisplayString	"This offers a means to customize how the object is shown in the inspector.	Do not override this method. Override gtDisplayOn: instead"			| limitedString limit |	limit := 1000.	limitedString := String streamContents: [:s | self gtDisplayOn: s] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , ' ...'! !!Object methodsFor: '*GT-Inspector' stamp: 'TudorGirba 6/28/2014 22:18'!gtInspectorInterestingObject	^ self! !!Object methodsFor: '*GT-Inspector' stamp: 'TudorGirba 12/23/2013 09:12'!gtDisplayOn: stream	"This offers a means to customize how the object is shown in the inspector"	^ self printOn: stream! !!Object methodsFor: '*GT-Inspector' stamp: 'TudorGirba 1/4/2016 20:59'!gtInspectorRawIn: composite	"This is the most basic presentation showing the state of the object"	^ composite custom: GTObjectVariablesBrowser new! !!Object methodsFor: '*GT-Inspector' stamp: 'AndreiChis 4/20/2016 17:54'!gtInspectorHash	^ self identityHash.! !!Object methodsFor: '*GT-Inspector' stamp: 'AndreiChis 2/7/2017 14:54'!gtInspectorVariableValuePairs	"This is a helper method that returns a collection of 		variable_name -> value	for the current object.	Subclasses can override it to specialize what appears in the variables presentation"	| bindings |	bindings := OrderedCollection new.	self gtInspectorVariableNodesIn: bindings.	^ bindings collect: [ :aNode | aNode key -> aNode value ]! !!Object methodsFor: '*GT-Inspector' stamp: 'AndreiChis 2/26/2017 18:03'!gtInspectorIcon	^ self iconOrThumbnailOfSize: 16! !!Object methodsFor: '*GT-Inspector' stamp: 'AndreiChis 2/26/2017 19:37'!gtInspectorVariableNodesIn: aCollection	"This is a helper method that adds to the given collection all nodes modeling named and 	indexed attributes for the current object.	Subclasses can override it to specialize what appears in the variables presentation."	| indexableDisplayLimit top bottom topLimit bottomLimit |		indexableDisplayLimit := GTInspector indexableDisplayLimit.        	top := 1.	bottom := self basicSize.	topLimit    := indexableDisplayLimit min: bottom.	bottomLimit := indexableDisplayLimit max: (bottom - indexableDisplayLimit).	top to: topLimit do: [ :index | 		aCollection add: (GTInspectorIndexedNode hostObject: self index: index) ].		bottomLimit + 1 to: bottom do: [ :index |		aCollection add: (GTInspectorIndexedNode hostObject: self index: index) ].		aCollection		addAll: ((self class allSlots collect: [ :slot | 			GTInspectorSlotNode hostObject: self slot: slot ]))! !!Object methodsFor: '*Epicea-Triggering' stamp: 'MartinDias 7/8/2015 17:03'!isEpiceaInterestingJobOwner	^ false! !!Object methodsFor: '*PharoDocComment' stamp: 'StephaneDucasse 11/3/2016 14:42'!>>> anObject	"Return a pair. It is handy to support the tweaking of pharo doc expression. A pharo doc expression is a comment as the following one:"	"4 + 3 >>> 7"	"4 + 4 >>> HKJ"		"so far the previous expression is not considered as faulty.	The following is a faulty expression"	"hjkjh >>> 6"	^ self -> anObject ! !!Object methodsFor: 'memory usage' stamp: 'monty 5/10/2017 19:54'!sizeInMemory	"Answer the number of bytes consumed by this instance including object header."	| contentBytes |	self class isImmediateClass		ifTrue: [ ^ 0 ].	contentBytes := Smalltalk wordSize.	"base header"	contentBytes := contentBytes + (self class instSize * Smalltalk wordSize).	"instance vars"	self class isVariable		ifTrue: [ | bytesPerElement |			"indexed elements"			bytesPerElement := self class isBytes				ifTrue: [ 1 ]				ifFalse: [ 4 ].			contentBytes := contentBytes + (self basicSize * bytesPerElement).			"If we are not filling an ammount of bytes multiple of the wordSize, we do it"			contentBytes \\ Smalltalk wordSize = 0				ifFalse: [ | extraBytesToFillAWord |					extraBytesToFillAWord := Smalltalk wordSize - (contentBytes \\ Smalltalk wordSize).					contentBytes := contentBytes + extraBytesToFillAWord ] ].	contentBytes > 255		ifTrue: [ contentBytes := contentBytes + (2 * Smalltalk wordSize) ]		ifFalse: [ contentBytes := contentBytes + Smalltalk wordSize ].	^ contentBytes! !!Object methodsFor: 'literal testing' stamp: 'ul 11/23/2010 13:28'!shouldBePrintedAsLiteral	^self isLiteral! !!Object methodsFor: 'literal testing' stamp: 'md 1/20/2006 17:09'!hasLiteralSuchThat: testBlock	"This is the end of the imbedded structure path so return false."	^ false! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/13/2013 23:43'!stonShouldWriteNilInstVars	"Return true if my instance variables that are nil should be written out, 	false otherwise. Overwrite when necessary. By default, return false."		^ false! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:22'!stonProcessSubObjects: block	"Execute block to (potentially) change each of my subObjects.	In general, all instance and indexable variables are processed.	Overwrite when necessary. Not used when #stonContainSubObjects returns false."		1 to: self class instSize do: [ :each |		self instVarAt: each put: (block value: (self instVarAt: each)) ].	(self class isVariable and: [ self class isBytes not ])		ifTrue: [			1 to: self basicSize do: [ :each |				self basicAt: each put: (block value: (self basicAt: each)) ] ]! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 5/28/2015 15:32'!fromSton: stonReader	"Decode non-variable classes from a map of their instance variables and values.	Override to customize and add a matching #toSton: (see implementors)."		self class isVariable 		ifTrue: [			stonReader error: 'custom #fromSton: implementation needed for variable/indexable class' ]		ifFalse: [			stonReader parseNamedInstVarsFor: self ]! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:24'!stonContainSubObjects	"Return true if I contain subObjects that should be processed, false otherwise.	Overwrite when necessary. See also #stonProcessSubObjects:"		^ true! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 5/28/2015 15:06'!stonOn: stonWriter	"Encode non-variable classes with a map of their instance variable and values.	Override to customize and add a matching #fromSton: (see implementors)."	self class isVariable 		ifTrue: [			stonWriter error: 'custom #stonOn: implementation needed for variable/indexable class' ]		ifFalse: [			stonWriter writeObject: self ]! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 4/14/2016 13:45'!stonPostReferenceResolution	"Hook that is called when references were resolved processing this object or one of its sub objects. This will most probably influence hash values. Override to take appropriate action."! !!Object methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 1/18/2012 20:16'!isStonReference	^ false! !!Object methodsFor: 'streaming' stamp: 'monty 8/29/2016 21:10'!putOn: aStream	aStream nextPut: self! !!Object methodsFor: '*OSWindow-Core' stamp: 'RonieSalgado 8/17/2016 22:08'!inspectInExternalWindow	^ GTInspector new openInExternalWindowOn: self! !!Object methodsFor: '*Reflectivity' stamp: 'MarcusDenker 4/28/2015 16:21'!asLiteralNode	^RBLiteralNode value: self! !!Object methodsFor: '*Reflectivity' stamp: 'DenisKudryashov 1/27/2017 10:18'!asMethodConstant	| const constNode link |	"this method will replace full sender message send of sender with me (or my value which usefull for block). So following sender method execution will not evaluate my receiver expresion but instead push precomputed literal with me"	const := self value.	constNode := thisContext sender sourceNodeExecuted.	link := MetaLink new		metaObject: const;		control: #instead.	constNode link: link.	^const! !!Object methodsFor: 'copying' stamp: 'CamilloBruni 10/2/2013 19:39'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."		| class selfNumberOfInstanceVariables fieldOfSelf copyOfSelf currentClass hasVeryDeepInnerMethod currentNumberOfInstanceVariables |		deepCopier references at: self ifPresent: [ :newer | 	"already copied" ^ newer].	class := self class.	class isMeta ifTrue: [ "a metaclass" ^ self ].	copyOfSelf := self shallowCopy.	deepCopier references at: self put: copyOfSelf.	"remember"			(class isVariable and: [class isPointers]) ifTrue: [		self basicSize to: 1 by: -1 do: [ :i |			fieldOfSelf := self basicAt: i. 			copyOfSelf 				basicAt: i				put: (deepCopier references 					at: fieldOfSelf					ifAbsent: [ fieldOfSelf veryDeepCopyWith: deepCopier ])]].		"Ask each superclass if it wants to share (weak copy) any inst vars"	copyOfSelf veryDeepInner: deepCopier.	"other superclasses want all instance variables deep copied"	currentClass := class.  	selfNumberOfInstanceVariables := class instSize.		[ selfNumberOfInstanceVariables == 0 ] whileFalse: [		hasVeryDeepInnerMethod := currentClass includesSelector: #veryDeepInner:.		currentNumberOfInstanceVariables := currentClass instSize - currentClass superclass instSize.		hasVeryDeepInnerMethod 			ifTrue: ["skip inst vars"				selfNumberOfInstanceVariables := selfNumberOfInstanceVariables - currentNumberOfInstanceVariables]				ifFalse: [ 				currentNumberOfInstanceVariables timesRepeat: [ 					fieldOfSelf := self instVarAt: selfNumberOfInstanceVariables.					copyOfSelf 						instVarAt: selfNumberOfInstanceVariables 						put: (deepCopier references 							at: fieldOfSelf 							ifAbsent: [ fieldOfSelf veryDeepCopyWith: deepCopier ]).					selfNumberOfInstanceVariables := selfNumberOfInstanceVariables - 1 ]].		currentClass := currentClass superclass ].			^ copyOfSelf! !!Object methodsFor: 'copying' stamp: 'StephaneDucasse 2/20/2010 21:42'!shallowCopy	"Answer a copy of the receiver which shares the receiver's instance variables. It should never be overridden. I'm invoked from the copy template method. Subclasses that need to specialize the copy should specialize the postCopy hook method."		| class newObject index |	<primitive: 148>	class := self class.	class isVariable		ifTrue: 			[index := self basicSize.			newObject := class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index).					index := index - 1]]		ifFalse: [newObject := class basicNew].	index := class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index).			index := index - 1].	^ newObject! !!Object methodsFor: 'copying' stamp: 'eem 6/11/2008 17:52'!copySameFrom: otherObject	"Copy to myself all instance variables named the same in otherObject.	This ignores otherObject's control over its own inst vars."	| myInstVars otherInstVars |	myInstVars := self class allInstVarNames.	otherInstVars := otherObject class allInstVarNames.	myInstVars doWithIndex: [:each :index | | match |		(match := otherInstVars indexOf: each) > 0 ifTrue:			[self instVarAt: index put: (otherObject instVarAt: match)]].	1 to: (self basicSize min: otherObject basicSize) do: [:i |		self basicAt: i put: (otherObject basicAt: i)].! !!Object methodsFor: 'copying' stamp: 'StephaneDucasse 2/20/2010 21:43'!veryDeepInner: deepCopier	"No special treatment for inst vars of my superclasses.  Override when some need to be weakly copied.  Object>>veryDeepCopyWith: will veryDeepCopy any inst var whose class does not actually define veryDeepInner:"	"avoid to use me we will deprecate it in the future"! !!Object methodsFor: 'copying' stamp: 'tpr 2/14/2004 21:53'!copyFrom: anotherObject	"Copy to myself all instance variables I have in common with anotherObject.  This is dangerous because it ignores an object's control over its own inst vars.  "	| mine his |	<primitive: 168>	mine := self class allInstVarNames.	his := anotherObject class allInstVarNames.	1 to: (mine size min: his size) do: [:ind |		(mine at: ind) = (his at: ind) ifTrue: [			self instVarAt: ind put: (anotherObject instVarAt: ind)]].	self class isVariable & anotherObject class isVariable ifTrue: [		1 to: (self basicSize min: anotherObject basicSize) do: [:ind |			self basicAt: ind put: (anotherObject basicAt: ind)]].! !!Object methodsFor: 'copying' stamp: 'StephaneDucasse 2/20/2010 21:43'!veryDeepFixupWith: deepCopier	"I have no fields and no superclass.  Catch the super call."		"avoid to use me we will deprecate it in the future"! !!Object methodsFor: 'copying' stamp: 'MarcusDenker 9/27/2010 15:28'!copy	"Answer another instance just like the receiver. Subclasses typically override postCopy; they typically do not override shallowCopy. Copy is a template method in the sense of Design Patterns. So do not override it. Override postCopy instead. Pay attention that normally you should call postCopy of your superclass too."	^self shallowCopy postCopy! !!Object methodsFor: 'copying' stamp: 'MarianoMartinezPeck 8/24/2012 15:58'!postCopy	"I'm a hook method in the sense of Design Patterns TemplateHook/Methods. I'm called by copy. self is a shallow copy, subclasses should copy fields as necessary to complete the full copy"	^ self ! !!Object methodsFor: 'copying' stamp: 'StephaneDucasse 2/20/2010 21:40'!deepCopy	"Answer a copy of the receiver with its own copy of each instance variable. deepCopy does a deep copy. It should never be overridden and only be used if you want to get these very specific semantics.It doesn't handle cycles, #veryDeepCopy does. In the future we will make it handle cycles and deprecate veryDeepCopy"	| newObject class index |	class := self class.	(class == Object) ifTrue: [^self].	class isVariable		ifTrue: 			[index := self basicSize.			newObject := class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index) deepCopy.					index := index - 1]]		ifFalse: [newObject := class basicNew].	index := class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index) deepCopy.			index := index - 1].	^newObject! !!Object methodsFor: 'copying' stamp: 'stephane.ducasse 6/1/2009 13:49'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy."	| copier new |	copier := DeepCopier new initialize: 4096 "self initialDeepCopierSize".	new := self veryDeepCopyWith: copier.	copier references associationsDo: [:assoc | 		assoc value veryDeepFixupWith: copier].	copier fixDependents.	^ new! !!Object methodsFor: 'copying' stamp: 'eem 12/1/2014 12:03'!clone	"Answer a shallow copy of the receiver."	<primitive: 148 error: ec>	| class newObject |	ec == #'insufficient object memory' ifFalse:		[^self primitiveFailed].	"If the primitive fails due to insufficient memory, instantiate via basicNew: to invoke	 the garbage collector before retrying, and use copyFrom: to copy state."	newObject := (class := self class) isVariable					ifTrue: 						[class isCompiledMethodClass							ifTrue:								[class newMethod: self basicSize - self initialPC + 1 header: self header]							ifFalse:								[class basicNew: self basicSize]]					ifFalse:						[class basicNew].	^newObject copyFrom: self! !!Object methodsFor: 'accessing'!basicSize	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0	! !!Object methodsFor: 'accessing' stamp: 'StephaneDucasse 9/24/2016 11:10'!yourself	"Answer self. The message yourself deserves a bit of explanation.	Sending yourself is handy to get the receiver of a message. It is especially useful when using a cascade since all the cascaded messages are send to the receiver. Let us look at an example.		Imagine that you have the following expression		#('hello' 'world') at: 2 put: 'pharo'	and that you would like to get the modified array #('hello' 'pharo') - the receiver of the message at:put:. 		Right now the expression #('hello' 'world') at: 2 put: 'pharo' returns 'pharo' and not the receiver because the message at:put: always returns the second argument.	 	To get the receiver we can simply use a cascade as follows:		#('hello' 'world') at: 2 put: 'pharo'; yourself	and since yourself returns the receiver of the message we will get the modified array.	Stepping back using a cascade and yourself is equivalent to declare a variable, assign the expression and return the variable as follows:	| a |	a := #('hello' 'world') at: 2 put: 'pharo'.	a 	"		^self! !!Object methodsFor: 'accessing'!basicAt: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'SeanDeNigris 4/24/2015 12:26'!at: index put: value 	"Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger ifTrue:		[self class isVariable			ifTrue: [(index between: 1 and: self size)					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]]			ifFalse: [self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'di 3/29/1999 13:10'!size	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 62>	self class isVariable ifFalse: [self errorNotIndexable].	^ 0! !!Object methodsFor: 'accessing' stamp: 'SeanDeNigris 4/24/2015 12:26'!basicAt: index put: value 	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive."	<primitive: 61>	index isInteger		ifTrue: [(index between: 1 and: self size)					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'MarianoMartinezPeck 8/24/2012 15:29'!at: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. See Object documentation 	whatIsAPrimitive. Read the class comment for a discussion about that the fact	that the index can be a float."	<primitive: 60>	index isInteger ifTrue:		[self class isVariable			ifTrue: [self errorSubscriptBounds: index]			ifFalse: [self errorNotIndexable]].	index isNumber		ifTrue: [^self at: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'printing' stamp: 'tk 10/19/2001 11:18'!longPrintOn: aStream limitedTo: sizeLimit indent: indent	"Append to the argument, aStream, the names and values of all of the receiver's instance variables.  Limit is the length limit for each inst var."	self class allInstVarNames doWithIndex:		[:title :index |		indent timesRepeat: [aStream tab].		aStream nextPutAll: title;		 nextPut: $:;		 space;		 tab;		 nextPutAll: 			((self instVarAt: index) printStringLimitedTo: (sizeLimit -3 -title size max: 1));		 cr]! !!Object methodsFor: 'printing' stamp: 'sma 6/1/2000 09:22'!printString	"Answer a String whose characters are a description of the receiver. 	If you want to print without a character limit, use fullPrintString."	^ self printStringLimitedTo: 50000! !!Object methodsFor: 'printing' stamp: 'sma 6/1/2000 09:28'!longPrintOn: aStream	"Append to the argument, aStream, the names and values of all 	of the receiver's instance variables."	self class allInstVarNames doWithIndex:		[:title :index |		aStream nextPutAll: title;		 nextPut: $:;		 space;		 tab;		 print: (self instVarAt: index);		 cr]! !!Object methodsFor: 'printing' stamp: 'BG 11/7/2004 13:39'!longPrintStringLimitedTo: aLimitValue	"Answer a String whose characters are a description of the receiver."		| str |	str := String streamContents: [:aStream | self longPrintOn: aStream limitedTo: aLimitValue indent: 0].	"Objects without inst vars should return something"	^ str isEmpty ifTrue: [self printString, String cr] ifFalse: [str]! !!Object methodsFor: 'printing'!isLiteral	"Answer whether the receiver has a literal text form recognized by the 	compiler."	^false! !!Object methodsFor: 'printing' stamp: 'di 6/20/97 08:57'!fullPrintString	"Answer a String whose characters are a description of the receiver."	^ String streamContents: [:s | self printOn: s]! !!Object methodsFor: 'printing'!storeOn: aStream 	"Append to the argument aStream a sequence of characters that is an 	expression whose evaluation creates an object similar to the receiver."	aStream nextPut: $(.	self class isVariable		ifTrue: [aStream nextPutAll: '(', self class name, ' basicNew: ';					store: self basicSize;					nextPutAll: ') ']		ifFalse: [aStream nextPutAll: self class name, ' basicNew'].	1 to: self class instSize do:		[:i |		aStream nextPutAll: ' instVarAt: ';			store: i;			nextPutAll: ' put: ';			store: (self instVarAt: i);			nextPut: $;].	1 to: self basicSize do:		[:i |		aStream nextPutAll: ' basicAt: ';			store: i;			nextPutAll: ' put: ';			store: (self basicAt: i);			nextPut: $;].	aStream nextPutAll: ' yourself)'! !!Object methodsFor: 'printing' stamp: 'di 6/20/97 09:12'!storeString	"Answer a String representation of the receiver from which the receiver 	can be reconstructed."	^ String streamContents: [:s | self storeOn: s]! !!Object methodsFor: 'printing' stamp: 'tk 10/16/2001 19:41'!longPrintString	"Answer a String whose characters are a description of the receiver."		| str |	str := String streamContents: [:aStream | self longPrintOn: aStream].	"Objects without inst vars should return something"	^ str isEmpty ifTrue: [self printString, String cr] ifFalse: [str]! !!Object methodsFor: 'printing' stamp: 'MarianoMartinezPeck 8/24/2012 15:28'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!Object methodsFor: 'printing' stamp: 'tk 5/7/1999 16:20'!printStringLimitedTo: limit	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| limitedString |	limitedString := String streamContents: [:s | self printOn: s] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!Object methodsFor: '*necompletion-extensions' stamp: 'EstebanLorenzano 4/11/2012 15:47'!isCodeCompletionAllowed	^false! !!Object methodsFor: '*Spec-Inspector' stamp: 'CamilloBruni 9/20/2013 19:27'!additionalInspectorClasses	"Answer addtional inspector classes that are used to show alternative views of instances of myself"	^ { }! !!Object methodsFor: '*Metacello-Core' stamp: 'dkh 6/21/2012 20:08'!metacelloSemanticIntegerLessThanSelf: anInteger    ^ self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*Metacello-Core' stamp: 'dkh 6/21/2012 20:09'!metacelloSemanticStringLessThanSelf: anInteger    ^ self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!metacelloVersionComponentLessThan: aMetacelloVersonComponent	^self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!metacelloIntegerLessThanSelf: anInteger	^self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!metacelloStringLessThanSelf: anInteger	^self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*Metacello-Core' stamp: 'dkh 6/21/2012 20:08'!metacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent    ^ self error: 'Invalid Metacello verson component - should be String or Integer.'! !!Object methodsFor: '*GT-SpotterExtensions-Core' stamp: 'TudorGirba 12/20/2016 06:06'!gtInspectorActionSpot	<gtInspectorAction>	^ GLMGenericAction new		action: [ 			GTSpotterMorph new				extent: (World width / 2.4 @ (World height / 1.6)) asIntegerPoint;				"extent: 400@500;"				doLayout;				spotterModel: (GTSpotter on: self);				openCenteredInWorld			 ];		icon: GLMUIThemeExtraIcons glamorousSearch;		condition: [ 				| fakeStep |				fakeStep := GTSpotter new newStep origin: self.				self spotterProcessorsFor: fakeStep.				fakeStep processors notEmpty ];		title: 'Search'! !!Object methodsFor: '*Monticello-Storing' stamp: 'CamilloBruni 8/1/2012 16:02'!comeFullyUpOnReload: smartRefStream	"Normally this read-in object is exactly what we want to store."	^ self! !!Object methodsFor: '*Monticello-Storing' stamp: 'MarianoMartinezPeck 5/21/2012 22:52'!storeDataOn: aDataStream	"Store myself on a DataStream.  Answer self.  This is a low-level DataStream/ReferenceStream method. See also objectToStoreOnDataStream.  NOTE: This method must send 'aDataStream beginInstance:size:' and then (nextPut:/nextPutWeak:) its subobjects.  readDataFrom:size: reads back what we write here."	| cntInstVars cntIndexedVars |	cntInstVars := self class instSize.	cntIndexedVars := self basicSize.	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	"Write fields of a variable length object. "	(self class isBits) ifFalse: [		1 to: cntIndexedVars do:			[:i | aDataStream nextPut: (self basicAt: i)]].! !!Object methodsFor: '*Monticello-Storing' stamp: 'tk 4/8/1999 12:05'!readDataFrom: aDataStream size: varsOnDisk	"Fill in the fields of self based on the contents of aDataStream.  Return self.	 Read in the instance-variables written by Object>>storeDataOn:.	 NOTE: This method must send beginReference: before reading any objects from aDataStream that might reference it.	 Allow aDataStream to have fewer inst vars.  See SmartRefStream."	| cntInstVars cntIndexedVars |	cntInstVars := self class instSize.	self class isVariable		ifTrue: [cntIndexedVars := varsOnDisk - cntInstVars.				cntIndexedVars < 0 ifTrue: [					self error: 'Class has changed too much.  Define a convertxxx method']]		ifFalse: [cntIndexedVars := 0.				cntInstVars := varsOnDisk]. 	"OK if fewer than now"	aDataStream beginReference: self.	1 to: cntInstVars do:		[:i | self instVarAt: i put: aDataStream next].	1 to: cntIndexedVars do:		[:i | self basicAt: i put: aDataStream next].	"Total number read MUST be equal to varsOnDisk!!"	^ self	"If we ever return something other than self, fix calls 			on (super readDataFrom: aDataStream size: anInteger)"! !!Object methodsFor: '*System-Caching' stamp: 'SvenVanCaekenberghe 12/16/2013 20:12'!asDoubleLink	^ DoubleLink value: self! !!Object methodsFor: '*OpalCompiler-Core' stamp: 'HenrikSperreJohansen 11/6/2015 11:18'!mustBeBooleanInMagic: context	"Permits to redefine methods inlined by compiler.	Take the ast node corresponding to the mustBeBoolean error, compile it on the with Opal fly and executes it as a DoIt. Then resume the execution of the context."	| sendNode methodNode method |	"get the message send node that triggered mustBeBoolean"	sendNode := context sourceNode sourceNodeForPC: context pc - 1.	"Build node to perform send unoptimized"	methodNode := RBMethodNode 		selector: #ExecuteUnOptimizedIn: 		arguments: { RBVariableNode named:'ThisContext' } 		body: sendNode copy asSequenceNode.	"Rewrite temps to access the values in context"	methodNode rewriteTempsForContext: context.	"Rewrite non-local returns to return to the correct context from send"	RBParseTreeRewriter new 		replace: '^ ``@value' with: 'ThisContext home return: ``@value';		executeTree: methodNode.	"Add a return to the method body"	methodNode body transformLastToReturn.		"Keep same compilation context as the sender node's"	methodNode compilationContext: sendNode methodNode compilationContext copy.	"Disable inlining so the message send will be unoptimized"	methodNode compilationContext compilerOptions: #(- optionInlineIf optionInlineAndOr optionInlineWhile).	"Generate the method"		method := methodNode generate.	"resume the context at the instruction following the send when returning from deoptimized code"	context pc: sendNode irInstruction nextBytecodeOffsetAfterJump.	"Execute the generated method"	^ context receiver withArgs: {context} executeMethod: method! !!Object methodsFor: 'halting' stamp: 'BenComan 1/28/2015 00:21'!haltIf: condition	<debuggerCompleteToSender>	Halt if: condition.! !!Object methodsFor: 'halting' stamp: 'BenComan 1/28/2015 00:18'!halt	"This is the typical message to use for inserting breakpoints during debugging."	<debuggerCompleteToSender>	Halt now! !!Object methodsFor: 'halting' stamp: 'BenComan 1/28/2015 00:21'!haltOnce	<debuggerCompleteToSender>	Halt once.! !!Object methodsFor: 'halting' stamp: 'BenComan 1/28/2015 00:20'!halt: aString 	<debuggerCompleteToSender>	Halt now: aString! !!Object methodsFor: 'halting' stamp: 'BenComan 1/28/2015 00:21'!haltOnCount: anInteger 	<debuggerCompleteToSender>	Halt onCount: anInteger.! !!Object methodsFor: '*Graphics-Display Objects' stamp: 'sw 3/26/2001 12:12'!printDirectlyToDisplay	"For debugging: write the receiver's printString directly to the display at (0, 100); senders of this are detected by the check-for-slips mechanism."	self asString displayAt: 0@100"StringMorph someInstance printDirectlyToDisplay"! !!Object methodsFor: '*Morphic-Base' stamp: 'ar 3/18/2001 00:03'!currentEvent	"Answer the current Morphic event.  This method never returns nil."	^ActiveEvent ifNil:[self currentHand lastEvent]! !!Object methodsFor: '*Morphic-Base' stamp: 'MarcusDenker 7/20/2012 14:57'!asStringMorph	"Open a StringMorph, as best one can, on the receiver"	^ self asString asStringMorph! !!Object methodsFor: '*Morphic-Base' stamp: 'BenjaminVanRyseghem 10/11/2013 15:28'!tail	^ nil! !!Object methodsFor: '*Morphic-Base' stamp: 'BenjaminVanRyseghem 11/27/2013 14:52'!wantsVisualFeedback	^ true! !!Object methodsFor: '*Morphic-Base' stamp: 'BenjaminVanRyseghem 5/16/2013 12:21'!transferFor: passenger from: aMorph	^ TransferMorph withPassenger: passenger from: aMorph! !!Object methodsFor: '*Morphic-Base' stamp: 'BenjaminVanRyseghem 10/11/2013 15:27'!head	^ self! !!Object methodsFor: '*Morphic-Base' stamp: 'BenjaminVanRyseghem 5/16/2013 12:27'!isTransferable	^ false! !!Object methodsFor: '*Morphic-Base' stamp: 'cb 6/25/2013 13:23'!defaultLabel	"Answer the default label to be used in morphs."	^ self class name! !!Object methodsFor: '*Morphic-Base' stamp: 'nk 9/1/2004 10:41'!currentHand	"Return a usable HandMorph -- the one associated with the object's current environment.  This method will always return a hand, even if it has to conjure one up as a last resort.  If a particular hand is actually handling events at the moment (such as a remote hand or a ghost hand), it will be returned."	^ActiveHand ifNil: [ self currentWorld primaryHand ]! !!Object methodsFor: '*Morphic-Base' stamp: 'AlainPlantec 12/19/2009 23:13'!hasModelYellowButtonMenuItems	^Morph cmdGesturesEnabled! !!Object methodsFor: '*Morphic-Base' stamp: 'nk 2/26/2004 13:35'!asTextMorph	"Open a TextMorph, as best one can, on the receiver"	^ TextMorph new contentsAsIs: self asStringOrText! !!Object methodsFor: '*Morphic-Base' stamp: 'StephaneDucasse 10/22/2014 21:27'!addModelYellowButtonMenuItemsTo: aCustomMenu forMorph: aMorph hand: aHandMorph 	"The receiver serves as the model for aMorph; a menu is being constructed for the morph, and here the receiver is able to add its own items"	Morph cmdGesturesEnabled ifTrue: [ 		aCustomMenu add: 'inspect model'  target: self selector: #inspect.	].	^aCustomMenu! !!Object methodsFor: '*Morphic-Base' stamp: 'dgd 9/25/2004 23:17'!iconOrThumbnailOfSize: aNumberOrPoint 	"Answer an appropiate form to represent the receiver"	^ nil! !!Object methodsFor: '*Morphic-Base' stamp: 'BenjaminVanRyseghem 2/7/2014 15:19'!asAlphaImageMorph	^ self asMorph! !!Object methodsFor: '*Morphic-Base' stamp: 'CamilloBruni 10/21/2012 23:38'!asDraggableMorph	^ self asStringMorph ! !!Object methodsFor: '*Morphic-Base' stamp: 'HenrikSperreJohansen 6/28/2010 12:24'!externalName	"Answer an external name by which the receiver is known. Generic	implementation here is a transitional backstop. probably"	^ [(self asString copyWithout: Character cr)		truncateTo: 27]		ifError: [ ^ self class name printString] ! !!Object methodsFor: '*Morphic-Base'!taskbarIcon	"Answer the icon for the receiver in a task bar	or nil for the default."	^self class taskbarIcon! !!Object methodsFor: '*Morphic-Base' stamp: 'BenjaminVanRyseghem 10/7/2011 21:36'!dragPassengersFor: item inMorph: dragSource 	^ { item }! !!Object methodsFor: '*Morphic-Base' stamp: 'AlainPlantec 10/20/2009 10:14'!asMorph	"Open a morph, as best one can, on the receiver"	^ self asStringMorph	"234 asMorph.(MenuIcons tinyMenuIcon) asMorph.'fred' asMorph."! !!Object methodsFor: 'pointing to' stamp: 'IgorStasenko 9/2/2012 02:24'!pointsOnlyWeaklyTo: anObject	"Assume, we already know that receiver points to an object,	answer true if receiver points only weakly to it "		self class isWeak ifFalse: [ ^ false ].	1 to: self class instSize do:		[:i | (self instVarAt: i) == anObject ifTrue: [^ false]].	^ true! !!Object methodsFor: 'casing-To be deprecated' stamp: 'StephaneDucasse 8/12/2013 21:27'!caseOf: aBlockAssociationCollection otherwise: aBlock	"DO NOT USE THIS METHOD!! It will be removed from Pharo."		"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, answer the result	 of evaluating aBlock."	aBlockAssociationCollection associationsDo:		[:assoc | (assoc key value = self) ifTrue: [^assoc value value]].	^ aBlock value"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"! !!Object methodsFor: 'casing-To be deprecated' stamp: 'StephaneDucasse 8/12/2013 21:27'!caseError	"DO NOT USE THIS METHOD!! It will be removed from Pharo."	"Report an error from an in-line or explicit case statement."	self error: 'Case not found (', self printString, '), and no otherwise clause'! !!Object methodsFor: 'casing-To be deprecated' stamp: 'StephaneDucasse 8/12/2013 21:27'!caseOf: aBlockAssociationCollection	"DO NOT USE THIS METHOD!! It will be removed from Pharo."	"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, report an error."	^ self caseOf: aBlockAssociationCollection otherwise: [self caseError]"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z""| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}"! !!Object methodsFor: 'class membership'!respondsTo: aSymbol 	"Answer whether the method dictionary of the receiver's class contains 	aSymbol as a message selector."	^self class canUnderstand: aSymbol! !!Object methodsFor: 'class membership'!isMemberOf: aClass 	"Answer whether the receiver is an instance of the class, aClass."	^self class == aClass! !!Object methodsFor: 'class membership'!isKindOf: aClass 	"Answer whether the class, aClass, is a superclass or class of the receiver."	self class == aClass		ifTrue: [^true]		ifFalse: [^self class inheritsFrom: aClass]! !!Object methodsFor: '*FFI-Kernel' stamp: 'ar 8/14/2006 23:02'!externalCallFailed	"Raise an error after a failed call to an external function"	| errCode |	errCode := ExternalFunction getLastError. "this allows us to look at the actual error code"	^self error: (ExternalFunction errorMessageFor: errCode).! !!Object methodsFor: '*qualityAssistantRecording' stamp: 'YuriyTymchuk 3/8/2016 23:15'!obfuscatedIfNecessary	^ GlobalIdentifier uniqueInstance obfuscateIfNecessary: self! !!Object methodsFor: '*qualityAssistantRecording' stamp: 'YuriyTymchuk 3/9/2016 00:34'!dataForQAR	^ Dictionary newFromPairs: {		#class . self class name obfuscatedIfNecessary }! !!Object methodsFor: 'user interface' stamp: 'sw 10/4/1999 08:13'!addModelItemsToWindowMenu: aMenu	"aMenu is being constructed to be presented to the user in response to the user's pressing on the menu widget in the title bar of a morphic window.  Here, the model is given the opportunity to add any model-specific items to the menu, whose default target is the SystemWindow itself."! !!Object methodsFor: 'user interface' stamp: 'HenrikNergaard 10/29/2016 15:26'!modelWakeUpIn: aWindow	"A window with me as model is being entered or expanded.  Default response is no-op" ! !!Object methodsFor: 'user interface' stamp: 'RAA 3/31/1999 12:13'!withoutListWrapper	^self! !!Object methodsFor: 'user interface' stamp: 'RAA 8/2/1999 12:41'!complexContents	^self! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:27'!finalize	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority."! !!Object methodsFor: 'finalization' stamp: 'Igor.Stasenko 5/25/2010 04:59'!hasMultipleExecutors	"All objects, except ObjectFinalizerCollection instances should answer false to this message"	^ false! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 18:38'!retryWithGC: execBlock until: testBlock	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."	| blockValue |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!Object methodsFor: 'finalization' stamp: 'ar 3/20/98 22:19'!executor	"Return an object which can act as executor for finalization of the receiver"	^self shallowCopy actAsExecutor! !!Object methodsFor: 'finalization' stamp: 'ar 5/19/2003 20:10'!finalizationRegistry	"Answer the finalization registry associated with the receiver."	^WeakRegistry default! !!Object methodsFor: 'finalization' stamp: 'StephaneDucasse 3/21/2010 15:13'!toFinalizeSend: aSelector to: aFinalizer with: aResourceHandle	"When I am finalized (e.g., garbage collected) close the associated resource handle by sending aSelector to the appropriate finalizer (the guy who knows how to get rid of the resource).	WARNING: Neither the finalizer nor the resource handle are allowed to reference me. If they do, then I will NEVER be garbage collected. Since this cannot be validated here, it is up to the client to make sure this invariant is not broken."	self == aFinalizer ifTrue:[self error: 'I cannot finalize myself'].	self == aResourceHandle ifTrue:[self error: 'I cannot finalize myself'].	^self finalizationRegistry add: self executor:		(ObjectFinalizer new			receiver: aFinalizer			selector: aSelector			argument: aResourceHandle)! !!Object methodsFor: 'finalization' stamp: 'EstebanLorenzano 10/13/2015 15:39'!actAsExecutor	"Prepare the receiver to act as executor for any resources associated with it"	self breakDependents! !!Object methodsFor: '*System-Settings' stamp: 'JurajKubelka 6/23/2015 12:49'!acceptSettings: aVisitor 	^ aVisitor visitObject: self! !!Object methodsFor: '*System-Support' stamp: 'MarcusDenker 7/12/2012 17:58'!systemNavigation	^ SystemNavigation new! !!Object methodsFor: 'flagging' stamp: 'sw 3/7/2001 13:14'!nominallyUnsent: aSelectorSymbol	"From within the body of a method which is not formally sent within the system, but which you intend to have remain in the system (for potential manual invocation, or for documentation, or perhaps because it's sent by commented-out-code that you anticipate uncommenting out someday, send this message, with the selector itself as the argument.This will serve two purposes:	(1)  The method will not be returned by searches for unsent selectors (because it, in a manner of speaking, sends itself).	(2)	You can locate all such methods by browsing senders of #nominallyUnsent:"	false ifTrue: [self flag: #nominallyUnsent:]    "So that this method itself will appear to be sent"! !!Object methodsFor: 'flagging' stamp: 'jm 3/18/98 17:23'!logEntry	Transcript show: 'Entered ', thisContext sender printString; cr.! !!Object methodsFor: 'flagging' stamp: 'MarcusDenker 9/14/2013 10:28'!isThisEverCalled: msg	"Send this message, with some useful printable argument, from methods or branches of methods which you believe are never reached."	self error: 'This is indeed called: ', msg printString! !!Object methodsFor: 'flagging' stamp: 'jm 3/18/98 17:23'!logExecution	Transcript show: 'Executing ', thisContext sender printString; cr.! !!Object methodsFor: 'flagging' stamp: 'sw 8/4/97 16:49'!isThisEverCalled	^ self isThisEverCalled: thisContext sender printString! !!Object methodsFor: 'flagging' stamp: 'jm 3/18/98 17:22'!logExit	Transcript show:  'Exited ', thisContext sender printString; cr.! !!Object methodsFor: '*Deprecated60' stamp: 'MarcusDenker 6/17/2016 10:55'!ifNotNilDo: aBlock ifNil: nilBlock	self		deprecated: 'Please use #ifNotNil:ifNil: instead'		transformWith: '`@receiver ifNotNilDo: `@statements1 ifNil: `@statements2'						 -> '`@receiver ifNotNil: `@statements1 ifNil: `@statements2'.	^ self ifNotNil: aBlock ifNil: nilBlock! !!Object methodsFor: '*Deprecated60' stamp: 'CyrilFerlicot 5/24/2016 21:06'!confirm: aString orCancel: cancelBlock	"Put up a yes/no/cancel menu with caption aString. Answer true if  	the response is yes, false if no. If cancel is chosen, evaluate  	cancelBlock. This is a modal question--the user must respond yes or no."	self		deprecated: 'Use UIManager default confirm:orCancel: instead.'		on: '05/24/2016'		in: #Pharo6.	^ UIManager default confirm: aString orCancel: cancelBlock! !!Object methodsFor: '*Deprecated60' stamp: 'MarcusDenker 6/17/2016 12:32'!ifNotNilDo: aBlock	self		deprecated: 'Please use #ifNotNil: instead'		transformWith: '`@receiver ifNotNilDo: `@statements' -> '`@receiver ifNotNil: `@statements'.	^ self ifNotNil: aBlock! !!Object methodsFor: '*Deprecated60' stamp: 'MarcusDenker 6/17/2016 10:56'!ifNil: nilBlock ifNotNilDo: aBlock	self		deprecated: 'Please use #ifNil:ifNotNil:  instead'		transformWith: '`@receiver ifNil: `@statements1 ifNotNilDo: `@statements2' 						-> '`@receiver ifNil: `@statements1 ifNotNil: `@statements2'.		^ self ifNil: nilBlock ifNotNil: aBlock! !!Object methodsFor: '*Deprecated60' stamp: 'GuillermoPolito 5/27/2016 10:42'!name	"Answer a name for the receiver.  This is used generically in the title of certain inspectors, such as the referred-to inspector, and specificially by various subsystems.  By default, we let the object just print itself out..  "	self		deprecated: 'Implement your own domain representation of an object, or use #asString or #printString instead.'		on: '27 May 2016'		in: #Pharo6. 	^ self printString! !!Object methodsFor: '*Tool-CriticBrowser' stamp: 'YuriyTymchuk 8/14/2016 11:59'!populateCBMenu: aMenu	aMenu add: 'Browse' target: self selector: #browse! !!Object methodsFor: '*Tool-Finder' stamp: 'MarcusDenker 9/20/2011 10:19'!closeTo: anObject	"Do not use this Method!! It is a workaround for MethodFinder"	^[self = anObject] ifError: [false]! !!Object methodsFor: '*Tool-Finder' stamp: 'pmm 3/13/2010 11:33'!copyTwoLevel	"one more level than a shallowCopy"	"do not use this method we will deprecated soon"	| newObject class index |	class := self class.	newObject := self shallowCopy.	newObject == self ifTrue: [^ self].	class isVariable		ifTrue: 			[index := self basicSize.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index) shallowCopy.					index := index - 1]].	index := class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index) shallowCopy.			index := index - 1].	^newObject! !!Object methodsFor: '*LibGit-Core-FFI-Handling' stamp: ' 10/26/2017 14:08:21'!handleLGitReturnCode	^ self! !!Object methodsFor: 'dependencies' stamp: 'sma 2/29/2000 19:52'!myDependents: aCollectionOrNil	"Private. Set (or remove) the receiver's dependents list."	aCollectionOrNil		ifNil: [DependentsFields removeKey: self ifAbsent: []]		ifNotNil: [DependentsFields at: self put: aCollectionOrNil]! !!Object methodsFor: 'dependencies' stamp: 'sma 2/29/2000 19:26'!canDiscardEdits	"Answer true if none of the views on this model has unaccepted edits that matter."	self dependents		do: [:each | each canDiscardEdits ifFalse: [^ false]]		without: self.	^ true! !!Object methodsFor: 'dependencies' stamp: 'PavelKrivanek 6/7/2016 13:54'!release	"Remove references to objects that may refer to the receiver. This message 	should be overridden by subclasses with any cycles, in which case the 	subclass should also include the expression super release."	! !!Object methodsFor: 'dependencies' stamp: 'ar 2/11/2001 01:55'!addDependent: anObject	"Make the given object one of the receiver's dependents."	| dependents |	dependents := self dependents.	(dependents includes: anObject) ifFalse:		[self myDependents: (dependents copyWithDependent: anObject)].	^ anObject! !!Object methodsFor: 'dependencies' stamp: 'sma 2/29/2000 19:58'!dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	^ self myDependents ifNil: [#()]! !!Object methodsFor: 'dependencies' stamp: 'sma 2/29/2000 19:55'!myDependents	"Private. Answer a list of all the receiver's dependents."	^ DependentsFields at: self ifAbsent: []! !!Object methodsFor: 'dependencies' stamp: 'sma 2/29/2000 20:23'!removeDependent: anObject	"Remove the given object as one of the receiver's dependents."	| dependents |	dependents := self dependents reject: [:each | each == anObject].	self myDependents: (dependents isEmpty ifFalse: [dependents]).	^ anObject! !!Object methodsFor: 'dependencies' stamp: 'sma 2/29/2000 19:53'!breakDependents	"Remove all of the receiver's dependents."	self myDependents: nil! !!Object methodsFor: '*System-Sources' stamp: 'MartinDias 6/22/2015 23:49'!isRemoteString	^ false! !!Object methodsFor: 'converting' stamp: 'HenrikSperreJohansen 10/18/2009 15:58'!asLink	"Answer a string that represents the receiver."	^ ValueLink value: self! !!Object methodsFor: 'converting' stamp: 'nice 3/28/2006 23:29'!adaptToInteger: rcvr andCompare: selector 	"If I am involved in comparison with an Integer.	Default behaviour is to process comparison as any other selectors."	^ self adaptToInteger: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'MarianoMartinezPeck 8/24/2012 15:58'!asString	"Answer a string that represents the receiver."	^ self printString ! !!Object methodsFor: 'converting' stamp: 'Igor.Stasenko 11/13/2009 06:03'!asSetElement	"Answer an object, which can be put into a Set as element , wrapped	by one of SetElement instance, if necessary. 	Default implementation is to answer self"! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:15'!adaptToFloat: rcvr andSend: selector	"If no method has been provided for adapting an object to a Float,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:14'!adaptToFraction: rcvr andSend: selector	"If no method has been provided for adapting an object to a Fraction,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'nice 3/28/2006 23:29'!adaptToFraction: rcvr andCompare: selector 	"If I am involved in comparison with a Fraction.	Default behaviour is to process comparison as any other selectors."	^ self adaptToFraction: rcvr andSend: selector! !!Object methodsFor: 'converting'!as: aSimilarClass	"Create an object of class aSimilarClass that has similar contents to the receiver."	^ aSimilarClass newFrom: self! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:15'!adaptToInteger: rcvr andSend: selector	"If no method has been provided for adapting an object to a Integer,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'sma 5/12/2000 17:39'!asOrderedCollection	"Answer an OrderedCollection with the receiver as its only element."	^ OrderedCollection with: self! !!Object methodsFor: 'converting' stamp: 'nice 3/28/2006 23:29'!adaptToFloat: rcvr andCompare: selector 	"If I am involved in comparison with a Float.	Default behaviour is to process comparison as any other selectors."	^ self adaptToFloat: rcvr andSend: selector! !!Object methodsFor: '*System-Object Events' stamp: 'nk 12/20/2002 17:48'!actionForEvent: anEventSelectorifAbsent: anExceptionBlock    "Answer the action to be evaluated when <anEventSelector> has been triggered."	| actions |	actions := self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil].	actions ifNil: [^anExceptionBlock value].	^ actions asMinimalRepresentation! !!Object methodsFor: '*System-Object Events' stamp: 'reThink 2/18/2001 15:21'!triggerEvent: anEventSelectorwithArguments: anArgumentList    ^(self actionForEvent: anEventSelector)        valueWithArguments: anArgumentList! !!Object methodsFor: '*System-Object Events' stamp: 'SqR 2/19/2001 14:04'!hasActionForEvent: anEventSelector    "Answer true if there is an action associated with anEventSelector"    ^(self actionForEvent: anEventSelector) notNil! !!Object methodsFor: '*System-Object Events' stamp: 'rw 2/10/2002 13:05'!createActionMap	^IdentityDictionary new! !!Object methodsFor: '*System-Object Events' stamp: 'reThink 2/18/2001 15:31'!removeAction: anActionforEvent: anEventSelector    self        removeActionsSatisfying: [:action | action = anAction]        forEvent: anEventSelector! !!Object methodsFor: '*System-Object Events' stamp: 'SqR 6/28/2001 13:19'!actionsDo: aBlock	self actionMap do: aBlock! !!Object methodsFor: '*System-Object Events' stamp: 'MarcusDenker 10/2/2013 20:15'!removeActionsSatisfying: aBlock	self actionMap keysDo:		[:eachEventSelector |			self   				removeActionsSatisfying: aBlock				forEvent: eachEventSelector		]! !!Object methodsFor: '*System-Object Events' stamp: 'MarcusDenker 7/23/2014 22:37'!triggerEvent: anEventSelectorwith: anObject    ^self 		triggerEvent: anEventSelector		withArguments: { anObject }! !!Object methodsFor: '*System-Object Events' stamp: 'rww 12/30/2002 10:37'!when: anEventSelectorsend: aMessageSelectorto: anObjectwithArguments: anArgArray     self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: anArgArray)! !!Object methodsFor: '*System-Object Events' stamp: 'reThink 2/18/2001 15:33'!removeActionsForEvent: anEventSelector    | map |    map := self actionMap.    map removeKey: anEventSelector asSymbol ifAbsent: [].    map isEmpty        ifTrue: [self releaseActionMap]! !!Object methodsFor: '*System-Object Events' stamp: 'rw 4/27/2002 08:35'!actionSequenceForEvent: anEventSelector    ^(self actionMap        at: anEventSelector asSymbol        ifAbsent: [^WeakActionSequence new])            asActionSequence! !!Object methodsFor: '*System-Object Events' stamp: 'gk 8/14/2007 23:53'!hasActionsWithReceiver: anObject	^self actionMap keys anySatisfy:		[:eachEventSelector |			(self actionSequenceForEvent: eachEventSelector)				anySatisfy: [:anAction | anAction receiver == anObject]]! !!Object methodsFor: '*System-Object Events' stamp: 'reThink 2/18/2001 15:36'!removeActionsWithReceiver: anObjectforEvent: anEventSelector    self        removeActionsSatisfying:            [:anAction |            anAction receiver == anObject]        forEvent: anEventSelector! !!Object methodsFor: '*System-Object Events' stamp: 'nk 12/20/2002 17:48'!actionForEvent: anEventSelector    "Answer the action to be evaluated when <anEventSelector> has been triggered."	| actions |	actions := self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil].	actions ifNil: [^nil].	^ actions asMinimalRepresentation! !!Object methodsFor: '*System-Object Events' stamp: 'reThink 2/18/2001 14:43'!actionMap	^EventManager actionMapFor: self! !!Object methodsFor: '*System-Object Events' stamp: 'reThink 2/18/2001 15:31'!removeActionsSatisfying: aOneArgBlock forEvent: anEventSelector    self        setActionSequence:            ((self actionSequenceForEvent: anEventSelector)                reject: [:anAction | aOneArgBlock value: anAction])        forEvent: anEventSelector! !!Object methodsFor: '*System-Object Events' stamp: 'rww 12/30/2002 10:37'!when: anEventSelectorsend: aMessageSelectorto: anObject     self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector)! !!Object methodsFor: '*System-Object Events' stamp: 'MarcusDenker 7/23/2014 22:37'!when: anEventSelectorsend: aMessageSelectorto: anObjectwith: anArg     self        when: anEventSelector        evaluate: (WeakMessageSend            receiver: anObject            selector: aMessageSelector		arguments: {anArg})! !!Object methodsFor: '*System-Object Events' stamp: 'rw 7/29/2003 17:18'!removeActionsWithReceiver: anObject	self actionMap copy keysDo:		[:eachEventSelector |			self   				removeActionsSatisfying: [:anAction | anAction receiver == anObject]				forEvent: eachEventSelector		]! !!Object methodsFor: '*System-Object Events' stamp: 'rw 4/27/2002 07:48'!asActionSequence	^WeakActionSequence with: self! !!Object methodsFor: '*System-Object Events' stamp: 'ClementBera 9/27/2013 17:54'!setActionSequence: actionSequenceforEvent: anEventSelector    | action |    action := actionSequence asMinimalRepresentation.    action 	  ifNil:            [self removeActionsForEvent: anEventSelector]        ifNotNil:            [self updateableActionMap                at: anEventSelector asSymbol                put: action]! !!Object methodsFor: '*System-Object Events' stamp: 'reThink 2/18/2001 15:33'!releaseActionMap	EventManager releaseActionMapFor: self! !!Object methodsFor: '*System-Object Events' stamp: 'reThink 2/18/2001 15:04'!when: anEventSelector evaluate: anAction 	| actions |	actions := self actionSequenceForEvent: anEventSelector.	(actions includes: anAction)		ifTrue: [^ self].	self 		setActionSequence: (actions copyWith: anAction)		forEvent: anEventSelector! !!Object methodsFor: '*System-Object Events' stamp: 'reThink 2/18/2001 15:22'!triggerEvent: anEventSelector	"Evaluate all actions registered for <anEventSelector>. Return the value of the last registered action."    ^(self actionForEvent: anEventSelector) value! !!Object methodsFor: '*System-Object Events' stamp: 'reThink 2/25/2001 08:50'!updateableActionMap	^EventManager updateableActionMapFor: self! !!Object methodsFor: 'deprecation' stamp: 'MarcusDenker 9/23/2016 13:44'!deprecated: anExplanationString	"Warn that the sending method has been deprecated"		Deprecation new		context: thisContext sender;		explanation: anExplanationString;		signal! !!Object methodsFor: 'deprecation' stamp: 'MarcusDenker 9/23/2016 13:44'!deprecated: anExplanationString transformWith: aRule	"Automatically tranform the deprecated call"		Deprecation new		context: thisContext sender;		explanation: anExplanationString;		rule: aRule;		transform.		! !!Object methodsFor: 'deprecation' stamp: 'MarcusDenker 9/23/2016 13:44'!deprecated: anExplanationString on: date in: version	"Warn that the sending method has been deprecated"		Deprecation new		context: thisContext sender;		explanation: anExplanationString;		date: date;		version: version;		signal! !!Object methodsFor: 'deprecation' stamp: 'MarcusDenker 9/23/2016 13:44'!deprecated: anExplanationString on: date in: version transformWith: aRule	"Automatically tranform the deprecated call"		Deprecation new		context: thisContext sender;		explanation: anExplanationString;		date: date;		version: version;		rule: aRule;		transform.		! !!Object methodsFor: '*Polymorph-Widgets' stamp: 'DenisKudryashov 11/4/2016 13:36'!systemIconName	^ #classIcon! !!Object methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/31/2009 15:52'!taskbarLabel	"Answer the label string for the receiver in a task bar	or nil for the default."	^self class taskbarLabel! !!Object methodsFor: '*Polymorph-Widgets' stamp: 'StephaneDucasse 10/12/2016 22:12'!iconNamed: aSymbol		^ Smalltalk ui icons iconNamed: aSymbol! !!Object methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/10/2007 11:41'!okToClose	"Sent to models when a window closing.	Allows this check to be independent of okToChange."		^true! !!Object methodsFor: '*Polymorph-Widgets' stamp: 'DenisKudryashov 11/10/2016 10:05'!systemIcon	"dont use this method. It will be deprecated.	Tools should resolve real icon object based on icon name"	^ self iconNamed: self systemIconName! !!Object methodsFor: 'reading' stamp: 'damiencassou 5/30/2008 10:56'!readFromString: aString 	"Create an object based on the contents of aString."	^ self readFrom: aString readStream! !!Object methodsFor: 'comparing' stamp: 'MarianoMartinezPeck 8/24/2012 15:58'!= anObject 	"Answer whether the receiver and the argument represent the same 	object. If = is redefined in any subclass, consider also redefining the 	message hash."	^self == anObject ! !!Object methodsFor: 'comparing'!~= anObject 	"Answer whether the receiver and the argument do not represent the 	same object."	^self = anObject == false! !!Object methodsFor: 'comparing' stamp: 'MarianoMartinezPeck 8/24/2012 15:58'!hash	"Answer a SmallInteger whose value is related to the receiver's identity.	May be overridden, and should be overridden in any classes that define = "	^ self identityHash ! !!Object methodsFor: 'comparing' stamp: 'ajh 2/2/2002 15:02'!literalEqual: other	^ self class == other class and: [self = other]! !!Object methodsFor: '*renraku' stamp: 'YuriyTymchuk 1/14/2016 00:08'!externalProperties	^ (Pragma allNamed: #eProperty from: self class to: ProtoObject) flatCollect: [ :pragma |		pragma method valueWithReceiver: self arguments: #() ]! !!Object methodsFor: '*renraku' stamp: 'Uko 10/7/2016 16:23:56'!spotterRePropertiesFor: aStep	<spotterOrder: 0>		ReSettings spotterPlugin ifFalse: [ ^ self ].		aStep listProcessor		title: 'Renraku Properties';		items: [ self externalProperties asArray ];		itemName: #title;		itemIcon: #icon;		filter: GTFilterSubstring! !!Object methodsFor: '*renraku' stamp: 'Uko 9/7/2016 00:38:48'!glmCritiqueSourceIn: composite	"display nothing for now"! !!Object methodsFor: '*renraku' stamp: 'YuriyTymchuk 1/20/2017 16:51'!gtInspectorEProportiesIn: composite	"This provides a list of all external properties"	<gtInspectorPresentationOrder: 20>	| eProperties ePropLazy |		ReSettings inspectorPluggin ifFalse: [ ^ self ].		ePropLazy := [		eProperties ifNil: [ eProperties := self externalProperties ] ].		composite list		when: [ ePropLazy value notEmpty ];		title: [ ePropLazy value size asString, (' property' asPluralBasedOn: ePropLazy value) ];		titleIcon: [ CircleMorph new				extent: 16 @ 16;				borderWidth: 0;				color: Color red darker darker;				addMorphCentered:					(ePropLazy value size asStringMorph						color: Color white;						emphasis: 1;						yourself);				iconOrThumbnail ];		display: [ ePropLazy value ];		icon: #icon;		format: #title! !!Object methodsFor: '*NewValueHolder' stamp: 'BenjaminVanRyseghem 1/24/2014 18:46'!asValueHolder	"See NewValueHolder class comment"	^ NewValueHolder value: self! !!Object methodsFor: '*UIManager' stamp: 'rbb 3/1/2005 09:26'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"nil confirm: 'Are you hungry?'"	^ UIManager default confirm: queryString! !!Object methodsFor: '*UIManager' stamp: 'pavel.krivanek 11/21/2008 16:50'!primitiveError: aString 	"This method is called when the error handling results in a recursion in 	calling on error: or halt or halt:."	UIManager default onPrimitiveError: aString.! !!Object methodsFor: '*UIManager' stamp: 'CamilloBruni 8/1/2012 16:09'!inform: aString	"Display a message for the user to read and then dismiss."	aString isEmptyOrNil ifFalse: [UIManager default inform: aString]! !!Object methodsFor: 'primitive failure' stamp: 'StephaneDucasse 12/5/2009 21:06'!primitiveFail	"primitiveFail may be invoked by certain methods whose code is translated in C. In such a case primitiveFail and not primitiveFailed	 should be invoked. The reason is that this code is translated to C by VMMaker. #primitiveFail is 	implemented in Interpreter of VMMaker."	^ self primitiveFailed! !!Object methodsFor: 'primitive failure' stamp: 'StephaneDucasse 3/27/2010 23:07'!primitiveFailed	"Announce that a primitive has failed and there is no appropriate Smalltalk code to run."	self primitiveFailed: thisContext sender selector! !!Object methodsFor: 'primitive failure' stamp: 'SvenVanCaekenberghe 4/20/2011 13:26'!primitiveFailed: selector	"Announce that a primitive has failed and there is no appropriate Smalltalk code to run."		PrimitiveFailed signalFor: selector! !!Object methodsFor: '*Tool-Base' stamp: 'MarcusDenker 9/28/2013 15:53'!inspectorClass	"Answer the class of the inspector to be used on the receiver.  Called by inspect; 	use basicInspect to get a normal (less useful) type of inspector."	^ Smalltalk tools inspectorClass! !!Object methodsFor: '*Tool-Base' stamp: 'EstebanLorenzano 3/20/2015 16:42'!basicInspect	^ Smalltalk tools basicInspector inspect: self! !!Object methodsFor: '*Tool-Base' stamp: 'MarcusDenker 9/28/2013 16:26'!inspectWithLabel: aLabel	"Create and schedule an Inspector in which the user can examine the receiver's variables."	^Smalltalk tools inspector inspect: self label: aLabel! !!Object methodsFor: '*Tool-Base' stamp: 'BenjaminVanRyseghem 1/7/2012 18:04'!browseHierarchy	self systemNavigation browseHierarchy: self class! !!Object methodsFor: '*Tool-Base' stamp: 'MarcusDenker 9/28/2013 15:39'!explore	^Smalltalk tools inspector explore: self! !!Object methodsFor: '*Tool-Base' stamp: 'MarcusDenker 8/11/2015 16:29'!browse	^ Smalltalk tools browser openOnClass: self class! !!Object methodsFor: '*Tool-Base' stamp: 'EstebanLorenzano 5/14/2013 09:43'!defaultBackgroundColor	"Answer the color to be used as the base window color for a window whose model is an object of the receiver's class"		"I don't want to do a self theme  because otherwise I will need to implement it on Object"	^  Smalltalk ui theme windowColorFor: self! !!Object methodsFor: '*Tool-Base' stamp: 'MarcusDenker 9/28/2013 15:49'!inspect	"Create and schedule an Inspector in which the user can examine the receiver's variables."	^ Smalltalk tools inspector inspect: self! !!Object methodsFor: '*Tool-Base' stamp: 'MarcusDenker 7/1/2016 18:09'!inspectOnce	"Inspect unless we have already done it once."		| node |	node := thisContext sender sourceNodeExecuted.	(node hasProperty: #Once) ifTrue: [^self]. 	node propertyAt: #Once put: true.	^self inspect! !!Object methodsFor: '*Tool-Base' stamp: 'MarcusDenker 9/28/2013 16:11'!inspector	^ Smalltalk tools inspector inspector: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Object class	instanceVariableNames: ''!!Object class methodsFor: '*Tools-Debugger' stamp: 'SeanDeNigris 5/28/2013 17:57'!canonicalArgumentName	| prefix |	prefix := self name first isVowel		ifTrue: [ 'an' ]		ifFalse: [ 'a' ].	^ prefix, self name.! !!Object class methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22'!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'.	See MetacelloConfigTemplate for example"		"noop by default"! !!Object class methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22'!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version.	 See MetacelloConfigTemplate."	^nil -> 'default'! !!Object class methodsFor: '*Tools-FileList' stamp: 'md 2/15/2006 17:20'!services	"Backstop"	^#()! !!Object class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 2/12/2012 19:58'!fromSton: stonReader	"Create a new instance and delegate decoding to instance side.	Override only when new instance should be created directly (see implementors). "		^ self new		fromSton: stonReader;		yourself! !!Object class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 8/12/2014 13:28'!stonName	"Override to encode my instances using a different class name."		^ self name! !!Object class methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/27/2014 11:08'!stonAllInstVarNames	"Override to encode my instances using a custom set of instance variables or to define their order."		^ self allInstVarNames ! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 02:00'!flushDependents	DependentsFields keysAndValuesDo:[:key :dep|		key ifNotNil:[key removeDependent: nil].	].	DependentsFields finalizeValues.! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 01:45'!reInitializeDependentsFields	"Object reInitializeDependentsFields"	| oldFields |	oldFields := DependentsFields.	DependentsFields := WeakIdentityKeyDictionary new.	oldFields keysAndValuesDo:[:obj :deps|		deps do:[:d| obj addDependent: d]].! !!Object class methodsFor: 'class initialization' stamp: 'MarianoMartinezPeck 8/24/2012 15:31'!initialize	"Object initialize"	DependentsFields ifNil:[self initializeDependentsFields].! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 01:41'!initializeDependentsFields	"Object initialize"	DependentsFields := WeakIdentityKeyDictionary new.! !!Object class methodsFor: '*Morphic-Base' stamp: 'DenisKudryashov 11/4/2016 16:15'!taskbarIconName	"Answer the icon for an instance of the receiver in a task bar"	^#smallWindowIcon! !!Object class methodsFor: '*Morphic-Base' stamp: 'DenisKudryashov 11/4/2016 16:00'!taskbarIcon	"Answer the icon for an instance of the receiver in a task bar"	^self iconNamed: self taskbarIconName! !!Object class methodsFor: 'instance creation' stamp: 'TorstenBergmann 5/12/2015 20:58'!newFrom: aSimilarObject	"Create an object that has similar contents to aSimilarObject. If the classes have any instance variables with the same names, copy them across. If this is bad for a class, override this method."	^ (self isVariable		ifTrue: [self basicNew: aSimilarObject basicSize]		ifFalse: [self basicNew]) copySameFrom: aSimilarObject! !!Object class methodsFor: 'instance creation' stamp: 'MarcusDenker 5/2/2013 11:24'!readFrom: textStringOrStream	"Create an object based on the contents of textStringOrStream."	| object |	object := self class compiler evaluate: textStringOrStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!Object class methodsFor: '*System-Support' stamp: 'MarianoMartinezPeck 8/24/2012 15:58'!registerToolsOn: aToolRegistry	" Override to register any tools for Smalltalk tools registry. " ! !!Object class methodsFor: '*System-FileRegistry' stamp: 'CamilloBruni 2/3/2013 17:21'!fileReaderServicesForFile: fullName suffix: suffix	<fileService>	"Backstop"	^#()! !!Object class methodsFor: '*System-FileRegistry' stamp: 'CamilloBruni 2/3/2013 17:27'!fileReaderServicesForDirectory: aFileDirectory	<directoryService>	"Backstop"	^#()! !!Object class methodsFor: 'documentation' stamp: 'MarcusDenker 6/9/2014 16:41'!howToModifyPrimitives	"You are allowed to write methods which specify primitives, but please use 	caution.  If you make a subclass of a class which contains a primitive method, 	the subclass inherits the primitive.  The message which is implemented 	primitively may be overridden in the subclass (E.g., see at:put: in String's 	subclass Symbol).  The primitive behavior can be invoked using super (see 	Symbol string:). 	 	A class which attempts to mimic the behavior of another class without being 	its subclass may or may not be able to use the primitives of the original class.  	In general, if the instance variables read or written by a primitive have the 	same meanings and are in the same fields in both classes, the primitive will 	work.  	For certain frequently used 'special selectors', the compiler emits a 	send-special-selector bytecode instead of a send-message bytecode.  	Special selectors were created because they offer two advantages.  Code 	which sends special selectors compiles into fewer bytes than normal.  For 	some pairs of receiver classes and special selectors, the interpreter jumps 	directly to a primitive routine without looking up the method in the class.  	This is much faster than a normal message lookup. 	 	A selector which is a special selector solely in order to save space has a 	normal behavior.  Methods whose selectors are special in order to 	gain speed contain the comment, 'No Lookup'.  When the interpreter 	encounters a send-special-selector bytecode, it checks the class of the 	receiver and the selector.  If the class-selector pair is a no-lookup pair, 	then the interpreter swiftly jumps to the routine which implements the 	corresponding primitive.  (A special selector whose receiver is not of the 	right class to make a no-lookup pair, is looked up normally).  The pairs are 	listed below.  No-lookup methods contain a primitive number specification, 	<primitive: xx>, which is redundant.  Since the method is not normally looked 	up, deleting the primitive number specification cannot prevent this 	primitive from running.  If a no-lookup primitive fails, the method is looked 	up normally, and the expressions in it are executed. 	 	No Lookup pairs of (class, selector) 	 	SmallInteger with any of		+ - * /  \\  bitOr: bitShift: bitAnd:  // 	SmallInteger with any of		=  ~=  >  <  >=  <= 	Any class with					== 	Any class with 					@ 	Point with either of				x y 	Context with					blockCopy: 	BlockContext with either of 		value value:	"	self error: 'comment only'! !!Object class methodsFor: 'documentation' stamp: 'MarcusDenker 7/7/2016 15:42'!whatIsAPrimitive	"Some messages in the system are responded to primitively. A primitive   	response is performed directly by the interpreter rather than by evaluating   	expressions in a method. The methods for these messages indicate the   	presence of a primitive response by including <primitive: xx> or 	<primitive: 79 error: ec>before the first expression in the method.   		In the second case, ec is a special temporary variable that holds an error code. 	In the VM primitive, failure is indicated by a variable called primFailCode being 	non-zero. On activating a method with a failing primitive, if the index is in 	bounds of the 	primitiveFailCodes array in the VMspecialObjectsArray then the 	failure code substitutes the symbol in the 	primitiveFailCodes array, otherwise 	it supplies the integer value.	  	Primitives exist for several reasons. Certain basic or 'primitive' 	operations cannot be performed in any other way. Smalltalk without 	primitives can move values from one variable to another, but cannot add two 	SmallIntegers together. Many methods for arithmetic and comparison 	between numbers are primitives. Some primitives allow Smalltalk to 	communicate with I/O devices such as the disk, the display, and the keyboard. 	Some primitives exist only to make the system run faster; each does the same 	thing as a certain Smalltalk method, and its implementation as a primitive is 	optional.  	  	When the Smalltalk interpreter begins to execute a method which specifies a 	primitive response, it tries to perform the primitive action and to return a 	result. If the routine in the interpreter for this primitive is successful, 	it will return a value and the expressions in the method will not be evaluated. 	If the primitive routine is not successful, the primitive 'fails', and the 	Smalltalk expressions in the method are executed instead. These 	expressions are evaluated as though the primitive routine had not been 	called.  	  	The Smalltalk code that is evaluated when a primitive fails usually 	anticipates why that primitive might fail. If the primitive is optional, the 	expressions in the method do exactly what the primitive would have done (See 	Number @). If the primitive only works on certain classes of arguments, the 	Smalltalk code tries to coerce the argument or appeals to a superclass to find 	a more general way of doing the operation (see SmallInteger +). If the 	primitive is never supposed to fail, the expressions signal an error (see 	SmallInteger asFloat).  	  	Each method that specifies a primitive has a comment in it. If the primitive is 	optional, the comment will say 'Optional'. An optional primitive that is not 	implemented always fails, and the Smalltalk expressions do the work 	instead.  	 	If a primitive is not optional, the comment will say, 'Essential'. Some 	methods will have the comment, 'No Lookup'. See Object 	howToModifyPrimitives for an explanation of special selectors which are 	not looked up.  	  	For the primitives for +, -, *, and bitShift: in SmallInteger, and truncated 	in Float, the primitive constructs and returns a 16-bit 	LargePositiveInteger when the result warrants it. Returning 16-bit 	LargePositiveIntegers from these primitives instead of failing is 	optional in the same sense that the LargePositiveInteger arithmetic 	primitives are optional. The comments in the SmallInteger primitives say, 	'Fails if result is not a SmallInteger', even though the implementor has the 	option to construct a LargePositiveInteger. For further information on 	primitives, see the 'Primitive Methods' part of the chapter on the formal 	specification of the interpreter in the Smalltalk book."			self error: 'comment only'! !!Object class methodsFor: '*Polymorph-Widgets' stamp: 'gvc 1/31/2009 15:53'!taskbarLabel	"Answer the label string for the receiver in a task bar	or nil for the default."	^nil! !Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'assertions' stamp: 'EstebanRey 11/19/2017 23:13'!assertHasIdInstanceVariable: aClass 			(aClass classThatDefinesInstanceVariable: #id) ifNil: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !Object subclass: #CustomerImport	instanceVariableNames: 'line readStream system record newCustomer'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerImport methodsFor: 'as yet unclassified' stamp: 'guidotripodi 11/17/2017 17:16'!importCustomerFromStream: aReadStream 	readStream := aReadStream .	self import .! !!CustomerImport methodsFor: 'importing' stamp: 'guidotripodi 11/18/2017 20:21'!importCustomer	newCustomer := (ImportData new) importNewCustomer: record.
	system persist: newCustomer. ! !!CustomerImport methodsFor: 'importing' stamp: 'HernanWilkinson 11/1/2016 17:51'!import

	[ self canImportNextLine ] whileTrue: [ 
		self convertLineToRecord.
		self importRecord ]! !!CustomerImport methodsFor: 'importing' stamp: 'guidotriopodi 11/16/2017 15:14'!canImportNextLine
	readStream ifNil: [^ self error: CustomerImport noCustomerForAddressErrorDescription ] .
	line := readStream nextLine.
	^ line notNil! !!CustomerImport methodsFor: 'importing' stamp: 'guidotripodi 11/18/2017 20:23'!importAddress	newCustomer		ifNil: [ ^ self error: CustomerImport noCustomerForAddressErrorDescription ].		^ newCustomer addAddress: ((ImportData new)  importNewAddress: record).! !!CustomerImport methodsFor: 'importing' stamp: 'guidotriopodi 11/16/2017 15:23'!importRecord
	
	record first = 'C' ifTrue: [ ^self importCustomer ].
	record first = 'A' ifTrue: [ ^self importAddress ].		^ self error: CustomerImport noCustomerForAddressErrorDescription.! !!CustomerImport methodsFor: 'importing' stamp: 'guidotriopodi 11/16/2017 14:48'!convertLineToRecord

	record := line substrings: {$,}.! !!CustomerImport methodsFor: 'initialization' stamp: 'guidotripodi 11/17/2017 17:07'!initializeOn: aReadStream on: aSession

	readStream := aReadStream.
	system := aSession.! !!CustomerImport methodsFor: 'initialization' stamp: 'guidotripodi 11/17/2017 17:07'!initializeFromSystem: aSystem 	system  := aSystem .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImport class	instanceVariableNames: ''!!CustomerImport class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 15:40'!from: aReadStream on: aSession

	^self new initializeOn: aReadStream on: aSession! !!CustomerImport class methodsFor: 'as yet unclassified' stamp: 'GUidoTripodi 11/18/2017 14:44'!noExistCustomer	^'El customer solicitado no existe.'! !!CustomerImport class methodsFor: 'as yet unclassified' stamp: 'guidotriopodi 11/16/2017 21:27'!fromSystem: aSystem 	^self new initializeFromSystem: aSystem ! !!CustomerImport class methodsFor: 'as yet unclassified' stamp: 'guidotriopodi 11/16/2017 15:02'!noCustomerForAddressErrorDescription		^'Datos de entrada invalidos. No se encuentra Customer para la direccion ingresada. Muchas gracias vuelva prontos.'! !TestCase subclass: #CustomerImportTest	instanceVariableNames: 'importer system inputStream'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerImportTest methodsFor: 'asserting' stamp: 'GUidoTripodi 11/18/2017 16:23'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize

	self assert: customer firstName equals: firstName.
	self assert: customer lastName equals: lastName.
	self assert: customer identificationType equals: idType.
	self assert: customer identificationNumber equals: idNumber.
	self assert: (customer addresses size) equals: addressesSize .! !!CustomerImportTest methodsFor: 'asserting' stamp: 'guidotriopodi 11/16/2017 15:05'!assertCorrectNumberOfCustomersWereImported: aNumber self assert: (self allCustomers) size equals: aNumber ! !!CustomerImportTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 11:00'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province

	| address |
	
	address := customer addressAt: streetName ifNone: [ self fail ].
	self assert: address streetName equals: streetName.
	self assert: address streetNumber equals: streetNumber.
	self assert: address town equals: town.
	self assert: address zipCode equals: zipCode.
	self assert: address province equals: province.
	! !!CustomerImportTest methodsFor: 'asserting' stamp: 'ivanpondal 11/14/2017 19:19'!assertPepeSanchezWasImportedCorrectly
	| customer idType idNumber |
	idType := 'D'.
	idNumber := '22333444'.
	customer := self
		customerIdentifiedAs: idType
		numbered: idNumber.
	self
		assert: customer
		isNamed: 'Pepe'
		lastName: 'Sanchez'
		identfiedAs: idType
		withNumber: idNumber
		andNumberOfAddresses: 2.
	self
		assert: customer
		hasAddressAt: 'San Martin'
		number: 3322
		in: 'Olivos'
		zipCode: 1636
		province: 'BsAs'.
	self
		assert: customer
		hasAddressAt: 'Maipu'
		number: 888
		in: 'Florida'
		zipCode: 1122
		province: 'Buenos Aires'! !!CustomerImportTest methodsFor: 'asserting' stamp: 'ivanpondal 11/14/2017 19:21'!assertJuanPerezWasImportedCorrectly
	| customer idType idNumber |
	idType := 'C'.
	idNumber := '23-25666777-9'.
	customer := self customerIdentifiedAs: idType numbered: idNumber.
	self
		assert: customer
		isNamed: 'Juan'
		lastName: 'Perez'
		identfiedAs: idType
		withNumber: idNumber
		andNumberOfAddresses: 1.
	self
		assert: customer
		hasAddressAt: 'Alem'
		number: 1122
		in: 'CABA'
		zipCode: 1001
		province: 'CABA'! !!CustomerImportTest methodsFor: 'customers' stamp: 'ivanpondal 11/14/2017 19:18'!allCustomers
	^ system selectAllCustomers! !!CustomerImportTest methodsFor: 'importing' stamp: 'EstebanRey 11/6/2017 21:22'!importCustomers	"	self importCustomers	"	| newCustomer line |	line := inputStream nextLine.	[ line notNil ]		whileTrue: [ (line beginsWith: 'C')				ifTrue: [ | customerData |					customerData := line substrings: {$,}.					newCustomer := Customer new.					newCustomer firstName: customerData second.					newCustomer lastName: customerData third.					newCustomer identificationType: customerData fourth.					newCustomer identificationNumber: customerData fourth.					session persist: newCustomer ].			(line beginsWith: 'A')				ifTrue: [ | addressData newAddress |					addressData := line substrings: {$,}.					newAddress := Address new.					newAddress streetName: addressData second.					newAddress streetNumber: addressData third asInteger.					newAddress town: addressData fourth.					newAddress zipCode: addressData fifth asInteger.					newAddress province: addressData fourth.					newCustomer addAddress: newAddress ].			line := inputStream nextLine ].! !!CustomerImportTest methodsFor: 'importing' stamp: 'guidotriopodi 11/16/2017 15:35'!importCustomersFrom: aInputStream
	| customer |	customer := CustomerImport from: aInputStream on: system.	customer import! !!CustomerImportTest methodsFor: 'importing' stamp: 'guidotriopodi 11/16/2017 15:31'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber
	
	^ system customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber! !!CustomerImportTest methodsFor: 'as yet unclassified' stamp: 'guidotriopodi 11/16/2017 15:07'!invalidDataInputFormated	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444,FloresA,San Martin,3322,Olivos,1636,BsAs,PeruA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImportTest methodsFor: 'as yet unclassified' stamp: 'guidotriopodi 11/16/2017 15:01'!invalidDataInput1AddressOnly	^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'as yet unclassified' stamp: 'guidotriopodi 11/16/2017 15:41'!validTestData	^ ReadStream on: 'C,Pepe,Sanchez,D,22333444,A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!CustomerImportTest methodsFor: 'as yet unclassified' stamp: 'guidotriopodi 11/16/2017 15:04'!emptyInput	^ ReadStream		on:			''! !!CustomerImportTest methodsFor: 'testing' stamp: 'guidotriopodi 11/16/2017 15:14'!test03AddressWithNoCustomerShouldRaiseError	inputStream := self invalidDataInput1AddressOnly.self		should: [ self importCustomersFrom: inputStream ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImport noCustomerForAddressErrorDescription ]! !!CustomerImportTest methodsFor: 'testing' stamp: 'guidotriopodi 11/16/2017 15:03'!test04InputEmptyShouldntRaiseErrors	self importCustomersFrom: self emptyInput.	self assertCorrectNumberOfCustomersWereImported: 0.! !!CustomerImportTest methodsFor: 'testing' stamp: 'guidotriopodi 11/16/2017 15:05'!test02verifyImportCustomerCorrectlyForReadStream

	self importCustomersFrom: self validTestData.

	self assertCorrectNumberOfCustomersWereImported: 2.
	self assertPepeSanchezWasImportedCorrectly.
	self assertJuanPerezWasImportedCorrectly! !!CustomerImportTest methodsFor: 'testing' stamp: 'guidotriopodi 11/16/2017 15:06'!test01verifyImportCustomerCorrectlyForFIleStream	inputStream := FileStream		fileNamed: '/home/guido/Documentos/FACU/INGS1/pharo6.1/input.txt'.
	self importCustomersFrom: inputStream.
	self assertCorrectNumberOfCustomersWereImported: 2.
	self assertPepeSanchezWasImportedCorrectly.
	self assertJuanPerezWasImportedCorrectly! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'BrianBokser 11/16/2017 12:24'!setUp
	system := Environment current newCustomerSystem.
	system start.
	system beginTransaction! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'Anonymous 11/13/2017 20:29'!addressMapping
	^ system addressMapping! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'ip 11/13/2017 20:30'!customerMapping
	^ system customerMapping! !!CustomerImportTest methodsFor: 'setup-teardown' stamp: 'ip 11/13/2017 21:06'!tearDown
	system commitTransaction.
	system stop! !Object subclass: #CustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerSystem methodsFor: 'setup-teardown' stamp: 'ivanpondal 11/14/2017 19:28'!beginTransaction
	self subclassResponsibility! !!CustomerSystem methodsFor: 'setup-teardown' stamp: 'ivanpondal 11/14/2017 19:28'!persist: aCustomer
	self subclassResponsibility! !!CustomerSystem methodsFor: 'setup-teardown' stamp: 'ivanpondal 11/14/2017 19:28'!start
	self subclassResponsibility! !!CustomerSystem methodsFor: 'setup-teardown' stamp: 'ivanpondal 11/14/2017 19:28'!commitTransaction
	self subclassResponsibility! !!CustomerSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 15:30'!persistObject: aPersistableObject 
	self subclassResponsibility! !!CustomerSystem methodsFor: 'setup-teardown' stamp: 'guidotriopodi 11/16/2017 15:31'!customerIdentifiedAs: anIdentificationType numbered: anIdentificationNumber
	self subclassResponsibility! !!CustomerSystem methodsFor: 'setup-teardown' stamp: 'ivanpondal 11/14/2017 19:28'!selectAllCustomers
	self subclassResponsibility! !!CustomerSystem methodsFor: 'setup-teardown' stamp: 'ivanpondal 11/14/2017 19:28'!stop
	self subclassResponsibility! !CustomerSystem subclass: #CustomerPersistentSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerPersistentSystem methodsFor: 'importing' stamp: 'guidotripodi 11/20/2017 14:22'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber
	| customers identification |		identification := Identification type: anIdentifycationType  number: anIdentificationNumber  .
	customers := identification giveMeElementFrom: session ofType: Customer. 
	^ customers anyOne! !!CustomerPersistentSystem methodsFor: 'customers' stamp: 'ivanpondal 11/14/2017 19:18'!selectAllCustomers
	^ session selectAllOfType: Customer! !!CustomerPersistentSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 16:47'!persistObject: aPersistableObject 		self persist: aPersistableObject .! !!CustomerPersistentSystem methodsFor: 'setup-teardown' stamp: 'Anonymous 11/13/2017 20:29'!addressMapping
	^ ClassMapping
		withDefaultTableNameFor: Address
		mappingAll:
			(Array
				with: (EmbededMapping withDefaultFieldNameFor: #streetName)
				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)
				with: (EmbededMapping withDefaultFieldNameFor: #town)
				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)
				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!CustomerPersistentSystem methodsFor: 'setup-teardown' stamp: 'ip 11/13/2017 21:04'!initialize
	super initialize.
	self initializeSession.! !!CustomerPersistentSystem methodsFor: 'setup-teardown' stamp: 'ivanpondal 11/14/2017 19:16'!commitTransaction
	session commit! !!CustomerPersistentSystem methodsFor: 'setup-teardown' stamp: 'ip 11/13/2017 20:30'!customerMapping
	^ ClassMapping
		withDefaultTableNameFor: Customer
		mappingAll:
			(Array
				with: (EmbededMapping withDefaultFieldNameFor: #firstName)
				with: (EmbededMapping withDefaultFieldNameFor: #lastName)
				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)
				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)
				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!CustomerPersistentSystem methodsFor: 'setup-teardown' stamp: 'ivanpondal 11/14/2017 19:15'!beginTransaction
	session beginTransaction! !!CustomerPersistentSystem methodsFor: 'setup-teardown' stamp: 'ivanpondal 11/14/2017 19:15'!start
	session open! !!CustomerPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:07'!initializeSession
	session :=
			(DataBaseSession
				for: (Array with: self addressMapping with: self customerMapping  ))! !!CustomerPersistentSystem methodsFor: 'setup-teardown' stamp: 'ivanpondal 11/14/2017 19:16'!persist: aCustomer 
	session persist: aCustomer! !!CustomerPersistentSystem methodsFor: 'setup-teardown' stamp: 'ivanpondal 11/14/2017 19:17'!stop
	session close! !CustomerSystem subclass: #CustomerTransientSystem	instanceVariableNames: 'customers session suppliers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!CustomerTransientSystem methodsFor: 'importing' stamp: 'ip 11/13/2017 21:07'!beginTransaction! !!CustomerTransientSystem methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 15:33'!persistSupplier: aSupplier 
	suppliers  add: aSupplier! !!CustomerTransientSystem methodsFor: 'importing' stamp: 'ip 11/13/2017 21:10'!persist: aCustomer 
	customers add: aCustomer! !!CustomerTransientSystem methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 15:33'!persistCustomer: aCustomer 
	customers add: aCustomer! !!CustomerTransientSystem methodsFor: 'importing' stamp: 'ip 11/13/2017 21:07'!start
! !!CustomerTransientSystem methodsFor: 'importing' stamp: 'ivanpondal 11/14/2017 19:12'!commitTransaction
! !!CustomerTransientSystem methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 15:32'!persistObject: aPersistableObject 
	"customers add: aCustomer"	aPersistableObject persistInto: self.! !!CustomerTransientSystem methodsFor: 'importing' stamp: 'guidotripodi 11/20/2017 14:23'!customerIdentifiedAs: anIdentificationType numbered: anIdentificationNumber
	| identifiedCustomers identification |	identification := Identification type: anIdentificationType  number: anIdentificationNumber  .
	identifiedCustomers := (identification giveMeElementFrom: customers).
	^ identifiedCustomers first! !!CustomerTransientSystem methodsFor: 'importing' stamp: 'ivanpondal 11/14/2017 19:13'!stop
! !!CustomerTransientSystem methodsFor: 'initialization' stamp: 'GUidoTripodi 11/18/2017 15:20'!initialize
	super initialize.
	customers := OrderedCollection new.	suppliers := OrderedCollection new.! !!CustomerTransientSystem methodsFor: 'customers' stamp: 'ivanpondal 11/14/2017 19:26'!selectAllCustomers
	^ customers! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Environment methodsFor: 'create' stamp: 'guidotripodi 11/19/2017 13:47'!newErpSystem
	self subclassResponsibility.! !!Environment methodsFor: 'create' stamp: 'BrianBokser 11/16/2017 12:03'!newCustomerSystem
	self subclassResponsibility.! !!Environment methodsFor: 'create' stamp: 'guidotripodi 11/19/2017 13:48'!newSupplierSystem
	self subclassResponsibility.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'accessing' stamp: 'BrianBokser 11/16/2017 12:05'!current
	| currentEnvironmentClass |
	currentEnvironmentClass := Environment allSubclasses detect: [ :anEnvirommentClass | anEnvirommentClass isCurrent  ] ifNone: [ Error signal: 'No current Environment' ].
	^ currentEnvironmentClass new.! !Environment subclass: #DevelopmentEnviroment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!DevelopmentEnviroment methodsFor: 'create' stamp: 'guidotripodi 11/19/2017 12:58'!newSupplierSystem
	^ SupplierTransientSystem new.! !!DevelopmentEnviroment methodsFor: 'create' stamp: 'GUidoTripodi 11/18/2017 17:28'!newCustomerSystem
	^ CustomerTransientSystem new.! !!DevelopmentEnviroment methodsFor: 'create' stamp: 'guidotripodi 11/19/2017 13:48'!newErpSystem
	^ SupplierTransientSystem new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelopmentEnviroment class	instanceVariableNames: ''!!DevelopmentEnviroment class methodsFor: 'testing' stamp: 'guidotripodi 11/20/2017 14:14'!isCurrent
	^ false.! !Object subclass: #ErpImport	instanceVariableNames: 'lines readStream session records input supplierImporter customerImporter system newParty'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ErpImport methodsFor: 'importing' stamp: 'guidotripodi 11/20/2017 14:14'!import
		self canImportNextLine ifTrue: [ 			self convertLineToRecord .
		records first = 'S' ifTrue: [supplierImporter importSupplierFromStream: input] ifFalse: [ 			customerImporter  importCustomerFromStream: input]. ]! !!ErpImport methodsFor: 'importing' stamp: 'guidotripodi 11/18/2017 19:02'!convertLineToRecord
	records := lines substrings: {$,}.! !!ErpImport methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 17:44'!canImportNextLine
	readStream ifNil: [^ self error: ErpImport  noCustomerForAddressErrorDescription ] .
	lines := readStream nextLine.
	^ lines notNil! !!ErpImport methodsFor: 'initialization' stamp: 'guidotripodi 11/18/2017 19:24'!initializeOn: aReadStream on: aSystem

	readStream := aReadStream.	input := aReadStream copy .
	system := aSystem.	customerImporter := CustomerImport fromSystem: aSystem . 	supplierImporter := SupplierImport fromSystem: aSystem . ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ErpImport class	instanceVariableNames: ''!!ErpImport class methodsFor: 'as yet unclassified' stamp: 'guidotriopodi 11/16/2017 21:21'!noCustomerForAddressErrorDescription		^'Datos de entrada invalidos. No se encuentra Customer para la direccion ingresada. Muchas gracias vuelva prontos.'! !!ErpImport class methodsFor: 'instance creation' stamp: 'guidotriopodi 11/16/2017 21:21'!from: aReadStream on: aSession

	^self new initializeOn: aReadStream on: aSession! !TestCase subclass: #ErpImportTest	instanceVariableNames: 'importer system inputStream'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ErpImportTest methodsFor: 'testing' stamp: 'guidotripodi 11/19/2017 14:04'!test02verifyImportSupplierAndCustomerCorrectlyForReadStream

	self importERPFrom:  self validTestData.

	self assertCorrectNumberOfCustomersWereImported: 2.
	self assertPepeSanchezWasImportedCorrectly.! !!ErpImportTest methodsFor: 'testing' stamp: 'GUidoTripodi 11/18/2017 17:30'!test05CustomerNoExistImposibleImporter	inputStream := self dataInputCustomerNonExist.self		should: [ self importERPFrom:  inputStream ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImport noExistCustomer ]! !!ErpImportTest methodsFor: 'testing' stamp: 'GUidoTripodi 11/18/2017 17:30'!test03AddressWithNoCustomerShouldRaiseError	inputStream := self invalidDataInput1AddressOnly.self		should: [ self importERPFrom:  inputStream ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImport noCustomerForAddressErrorDescription ]! !!ErpImportTest methodsFor: 'testing' stamp: 'guidotripodi 11/19/2017 14:05'!test06verifyImportCustomerCorrectlyForReadStream

	self importERPFrom:  self validTestDataCustomerSolo .

	self assertCorrectNumberOfCustomersWereImported: 2.
	self assertPepeSanchezWasImportedCorrectlySOLOCUSTOMER.! !!ErpImportTest methodsFor: 'testing' stamp: 'GUidoTripodi 11/18/2017 17:30'!test04InputEmptyShouldntRaiseErrors	self importERPFrom:  self emptyInput.	self assertCorrectNumberOfCustomersWereImported: 0.! !!ErpImportTest methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:47'!setUp
	system := Environment current newErpSystem.
	system start.
	system beginTransaction! !!ErpImportTest methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:29'!addressMapping
	^ system addressMapping! !!ErpImportTest methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:29'!customerMapping
	^ system customerMapping! !!ErpImportTest methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:29'!tearDown
	system commitTransaction.
	system stop! !!ErpImportTest methodsFor: 'asserting' stamp: 'GUidoTripodi 11/18/2017 17:29'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize

	self assert: customer firstName equals: firstName.
	self assert: customer lastName equals: lastName.
	self assert: customer identificationType equals: idType.
	self assert: customer identificationNumber equals: idNumber.
	self assert: (customer addresses size) equals: addressesSize .! !!ErpImportTest methodsFor: 'asserting' stamp: 'guidotripodi 11/19/2017 14:06'!assertPepeSanchezWasImportedCorrectlySOLOCUSTOMER
	| customer idType idNumber |
	idType := 'D'.
	idNumber := '22333444'.
	customer := self
		customerIdentifiedAs: idType
		numbered: idNumber.
	self
		assert: customer
		isNamed: 'Pepe'
		lastName: 'Sanchez'
		identfiedAs: idType
		withNumber: idNumber
		andNumberOfAddresses: 2.
	self
		assert: customer
		hasAddressAt: 'San Martin'
		number: 3322
		in: 'Olivos'
		zipCode: 1636
		province: 'BsAs'.
	self
		assert: customer
		hasAddressAt: 'Maipu'
		number: 888
		in: 'Florida'
		zipCode: 1122
		province: 'Buenos Aires'! !!ErpImportTest methodsFor: 'asserting' stamp: 'GUidoTripodi 11/18/2017 17:29'!assertCorrectNumberOfCustomersWereImported: aNumber self assert: (self allCustomers) size equals: aNumber ! !!ErpImportTest methodsFor: 'asserting' stamp: 'GUidoTripodi 11/18/2017 17:29'!assert: supplier hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province

	| address |
	
	address := supplier addressAt: streetName ifNone: [ self fail ].
	self assert: address streetName equals: streetName.
	self assert: address streetNumber equals: streetNumber.
	self assert: address town equals: town.
	self assert: address zipCode equals: zipCode.
	self assert: address province equals: province.
	! !!ErpImportTest methodsFor: 'asserting' stamp: 'GUidoTripodi 11/18/2017 17:29'!assertPepeSanchezWasImportedCorrectly
	| customer supplier |
	customer := self
		customerIdentifiedAs: 'D'
		numbered: '22333444'.	supplier := self supplierIdentifiedAs: 'D'
		numbered: '123'.
	self
		assert: customer
		isNamed: 'Pepe'
		lastName: 'Sanchez'
		identfiedAs: 'D'
		withNumber: '22333444'
		andNumberOfAddresses: 0.
	self
		assert: supplier
		hasAddressAt: 'San Martin'
		number: 3322
		in: 'Olivos'
		zipCode: 1636
		province: 'BsAs'.
	self
		assert: supplier
		hasAddressAt: 'Maipu'
		number: 888
		in: 'Florida'
		zipCode: 1122
		province: 'Buenos Aires'! !!ErpImportTest methodsFor: 'as yet unclassified' stamp: 'GUidoTripodi 11/18/2017 17:29'!validTestData	^ ReadStream on: 'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444NC,Arturo,Sanchez,D,12345EC,D,12345A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!ErpImportTest methodsFor: 'as yet unclassified' stamp: 'GUidoTripodi 11/18/2017 17:29'!emptyInput	^ ReadStream		on:			''! !!ErpImportTest methodsFor: 'as yet unclassified' stamp: 'guidotripodi 11/19/2017 14:06'!validTestDataCustomerSolo	^ ReadStream on: 'C,Pepe,Sanchez,D,22333444,A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!ErpImportTest methodsFor: 'as yet unclassified' stamp: 'GUidoTripodi 11/18/2017 17:29'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber 	^ system supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber! !!ErpImportTest methodsFor: 'as yet unclassified' stamp: 'GUidoTripodi 11/18/2017 17:29'!invalidDataInput1AddressOnly	^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!ErpImportTest methodsFor: 'as yet unclassified' stamp: 'GUidoTripodi 11/18/2017 17:29'!invalidDataInputFormated	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444,FloresA,San Martin,3322,Olivos,1636,BsAs,PeruA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!ErpImportTest methodsFor: 'as yet unclassified' stamp: 'GUidoTripodi 11/18/2017 17:29'!dataInputCustomerNonExist	^ ReadStream on: 'S,Supplier1,D,123 NC,Pepe,Sanchez,D,22333444EC,D,5456774A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!ErpImportTest methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 17:30'!importERPFrom: aInputStream
	| erpImporter |	erpImporter := ErpImport  from: aInputStream on: system.	erpImporter import! !!ErpImportTest methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 17:29'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber
	
	^ system customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber! !!ErpImportTest methodsFor: 'customers' stamp: 'GUidoTripodi 11/18/2017 17:29'!allCustomers
	^ system selectAllCustomers! !Object subclass: #ErpSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ErpSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!persistObject: aPersistableObject 
	self subclassResponsibility! !!ErpSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!customerIdentifiedAs: anIdentificationType numbered: anIdentificationNumber
	self subclassResponsibility! !!ErpSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!commitTransaction
	self subclassResponsibility! !!ErpSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!beginTransaction
	self subclassResponsibility! !!ErpSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!start
	self subclassResponsibility! !!ErpSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!findCustomerByType: aType andIdentification: aIndentification
	self subclassResponsibility! !!ErpSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!persist: aCustomer
	self subclassResponsibility! !!ErpSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber 
	self subclassResponsibility! !!ErpSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!stop
	self subclassResponsibility! !!ErpSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!selectAllCustomers
	self subclassResponsibility! !ErpSystem subclass: #ErpPersistentSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ErpPersistentSystem methodsFor: 'importing' stamp: 'guidotripodi 11/19/2017 13:48'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber
	| customers|
	customers := session
		select: [ :aCustomer | 
			aCustomer identificationType = anIdentifycationType
				and: [ aCustomer identificationNumber = anIdentificationNumber ] ]
		ofType: Customer.		customers isEmpty ifFalse: [ ^ customers anyOne] ifTrue: [^ self error: CustomerImport noExistCustomer].! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!persistObject: aPersistableObject 		aPersistableObject persistInto: self.! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!addressMapping
	^ ClassMapping
		withDefaultTableNameFor: Address
		mappingAll:
			(Array
				with: (EmbededMapping withDefaultFieldNameFor: #streetName)
				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)
				with: (EmbededMapping withDefaultFieldNameFor: #town)
				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)
				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!initialize
	super initialize.
	self initializeSession.! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!customerMapping
	^ ClassMapping
		withDefaultTableNameFor: Customer
		mappingAll:
			(Array
				with: (EmbededMapping withDefaultFieldNameFor: #firstName)
				with: (EmbededMapping withDefaultFieldNameFor: #lastName)
				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)
				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)
				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!commitTransaction
	session commit! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!beginTransaction
	session beginTransaction! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!start
	session open! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!findCustomerByType: aType andIdentification: aIndentification	^self customerIdentifiedAs: aType  numbered: aIndentification! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!initializeSession
	session :=
			(DataBaseSession
				for: (Array with: self addressMapping with: self customerMapping with: self supplierMapping  ))! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!persist: aCustomer 
	session persist: aCustomer! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber 	| suppliers |
	suppliers := session
		select: [ :aSupplier | 
			aSupplier identificationType = anIdentifycationType
				and: [ aSupplier identificationNumber = anIdentificationNumber ] ]
		ofType: Supplier .
	^ suppliers anyOne! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!supplierMapping
	^ ClassMapping
		withDefaultTableNameFor: Supplier 
		mappingAll:
			(Array
				with: (EmbededMapping withDefaultFieldNameFor: #name)
				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)
				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)
				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer))! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!persistSupplier: aSupplier 
 session persist:  aSupplier! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:48'!stop
	session close! !!ErpPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/20/2017 11:03'!persistCustomer: aCustomer 	! !!ErpPersistentSystem methodsFor: 'customers' stamp: 'guidotripodi 11/19/2017 13:48'!selectAllCustomers
	^ session selectAllOfType: Customer! !ErpSystem subclass: #ErpTransientSystem	instanceVariableNames: 'customers session suppliers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ErpTransientSystem methodsFor: 'initialization' stamp: 'guidotripodi 11/19/2017 13:49'!initialize
	super initialize.
	customers := OrderedCollection new.	suppliers := OrderedCollection new.! !!ErpTransientSystem methodsFor: 'customers' stamp: 'guidotripodi 11/19/2017 13:49'!findCustomerByType: aType andIdentification: aIndentification
		| collectionCustomer |	collectionCustomer := OrderedCollection new.	collectionCustomer := ( customers select:[:customer | customer identificationType = aType and: ( customer identificationNumber = aIndentification )]).	collectionCustomer isEmpty ifFalse: [ ^(collectionCustomer first) ] ifTrue: [^ self error: CustomerImport noExistCustomer].! !!ErpTransientSystem methodsFor: 'customers' stamp: 'guidotripodi 11/19/2017 13:49'!selectAllCustomers
	^ customers! !!ErpTransientSystem methodsFor: 'importing' stamp: 'guidotripodi 11/19/2017 13:49'!beginTransaction! !!ErpTransientSystem methodsFor: 'importing' stamp: 'guidotripodi 11/19/2017 13:49'!persistSupplier: aSupplier 
	suppliers  add: aSupplier! !!ErpTransientSystem methodsFor: 'importing' stamp: 'guidotripodi 11/19/2017 13:49'!persist: aCustomer 
	customers add: aCustomer! !!ErpTransientSystem methodsFor: 'importing' stamp: 'guidotripodi 11/19/2017 13:49'!persistCustomer: aCustomer 
	customers add: aCustomer! !!ErpTransientSystem methodsFor: 'importing' stamp: 'guidotripodi 11/19/2017 13:49'!start
! !!ErpTransientSystem methodsFor: 'importing' stamp: 'guidotripodi 11/19/2017 13:49'!commitTransaction
! !!ErpTransientSystem methodsFor: 'importing' stamp: 'guidotripodi 11/19/2017 13:49'!persistObject: aPersistableObject 
	"customers add: aCustomer"	aPersistableObject persistInto: self.! !!ErpTransientSystem methodsFor: 'importing' stamp: 'guidotripodi 11/20/2017 14:23'!customerIdentifiedAs: anIdentificationType numbered: anIdentificationNumber
	| identifiedCustomers identification |	identification := Identification type: anIdentificationType  number: anIdentificationNumber  .
	identifiedCustomers := (identification giveMeElementFrom: customers).
	^ identifiedCustomers first! !!ErpTransientSystem methodsFor: 'importing' stamp: 'guidotripodi 11/19/2017 13:49'!stop
! !!ErpTransientSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/20/2017 14:23'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	| identifiedSuppliers identification |	identification := Identification type: anIdentifycationType  number: anIdentificationNumber  .
	identifiedSuppliers := (identification giveMeElementFrom: suppliers).
	^ identifiedSuppliers first! !Object subclass: #Identification	instanceVariableNames: 'identificationType identificationNumber'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Identification methodsFor: 'as yet unclassified' stamp: 'guidotripodi 11/20/2017 14:23'!giveMeElementFrom: aCollection 	| collection |	collection := aCollection
		select: [ :aElement |			(self validType: aElement identificationType andNumber: aElement identificationNumber ) ].		^collection.! !!Identification methodsFor: 'as yet unclassified' stamp: 'guidotripodi 11/20/2017 13:48'!validType: aType andNumber: aNumber 	^ (identificationNumber = aNumber and: identificationType = aType) .! !!Identification methodsFor: 'as yet unclassified' stamp: 'guidotripodi 11/20/2017 14:22'!giveMeElementFrom: aSession ofType: aClass 	| collection |	collection := aSession
		select: [ :aElement |			(self validType: aElement identificationType andNumber: aElement identificationNumber ) ]
		ofType: aClass.		^collection .! !!Identification methodsFor: 'as yet unclassified' stamp: 'guidotripodi 11/20/2017 13:48'!initialize: aType number: aNumber 	identificationType := aType .	identificationNumber := aNumber .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Identification class	instanceVariableNames: ''!!Identification class methodsFor: 'as yet unclassified' stamp: 'guidotripodi 11/20/2017 13:46'!type: aType number: aNumber 	^self new initialize: aType number: aNumber.! !Object subclass: #ImportData	instanceVariableNames: 'customer addresss newSupplier'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!ImportData methodsFor: 'as yet unclassified' stamp: 'guidotripodi 11/18/2017 20:32'!importNewSupplier: aRecord	aRecord size ~= 4		ifTrue: [ ^ self error: SupplierImport noCustomerForAddressErrorDescription ].	newSupplier := Supplier new.	newSupplier name: aRecord second.	newSupplier identificationType: aRecord third.	newSupplier identificationNumber: aRecord fourth.	^newSupplier.	! !!ImportData methodsFor: 'importing' stamp: 'guidotripodi 11/18/2017 20:22'!importNewAddress: aRecord	| newAddress |		aRecord size ~= 6		ifTrue: [ self error: CustomerImport noCustomerForAddressErrorDescription ].		newAddress := Address new.	newAddress streetName: aRecord second.	newAddress streetNumber: aRecord third asInteger.	newAddress town: aRecord fourth.	newAddress zipCode: aRecord fifth asInteger.	newAddress province: aRecord sixth.	^ newAddress! !!ImportData methodsFor: 'importing' stamp: 'guidotripodi 11/18/2017 20:18'!importNewCustomer: aRecord	aRecord  size ~= 5 ifTrue: [^ self error: CustomerImport noCustomerForAddressErrorDescription].	customer  := Customer new.	customer firstName: aRecord second.	customer lastName: aRecord third.	customer identificationType: aRecord fourth.	customer identificationNumber: aRecord fifth.	^customer.! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!IntegrationEnvironment methodsFor: 'instance creation' stamp: 'guidotripodi 11/19/2017 12:57'!newSupplierSystem	^ SupplierPersistentSystem new.! !!IntegrationEnvironment methodsFor: 'instance creation' stamp: 'guidotripodi 11/19/2017 13:48'!newErpSystem	^ SupplierPersistentSystem new.! !!IntegrationEnvironment methodsFor: 'create' stamp: 'GUidoTripodi 11/18/2017 17:28'!newCustomerSystem
	^ CustomerPersistentSystem new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'testing' stamp: 'guidotripodi 11/20/2017 14:14'!isCurrent
	^ true.! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'assertions' stamp: 'EstebanRey 11/19/2017 23:15'!assertIsValidFor: aClass 		(aClass classThatDefinesInstanceVariable: instanceVariableName) ifNil: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] 	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'assertions' stamp: 'EstebanRey 11/19/2017 23:14'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName mappings'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'mapping' stamp: 'guidotripodi 11/19/2017 13:02'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 	! !!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !Object subclass: #Party	instanceVariableNames: 'id identificationType identificationNumber addresses'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Party methodsFor: 'accessing' stamp: 'EstebanRey 11/19/2017 23:49'!identificationNumber
	^identificationNumber .! !!Party methodsFor: 'accessing' stamp: 'EstebanRey 11/19/2017 23:47'!identificationType
	^identificationType .! !!Party methodsFor: 'accessing' stamp: 'EstebanRey 11/19/2017 23:47'!identificationType: aType
	identificationType := aType .! !!Party methodsFor: 'accessing' stamp: 'EstebanRey 11/19/2017 23:49'!identificationNumber: aNumber
	identificationNumber := aNumber .! !!Party methodsFor: 'accessing' stamp: 'guidotripodi 11/20/2017 13:42'!identificationType: aType aNumber: aNumber 	| identification |	identification := Identification type: self identificationType number: self identificationNumber .	
	^(identification validType: aType andNumber: aNumber ).! !!Party methodsFor: 'addresses' stamp: 'EstebanRey 11/19/2017 23:09'!persistInto: aSystem
	self subclassResponsibility! !!Party methodsFor: 'adding' stamp: 'EstebanRey 11/19/2017 23:50'!addresses
	^addresses .! !!Party methodsFor: 'adding' stamp: 'EstebanRey 11/19/2017 23:43'!addressAt: aStreetName ifNone: noneClosure 
	
	^addresses detect: [ :anAddress | anAddress streetName = aStreetName ] ifNone: noneClosure ! !!Party methodsFor: 'adding' stamp: 'EstebanRey 11/19/2017 23:09'!include: aCustomer
	self subclassResponsibility! !!Party methodsFor: 'adding' stamp: 'EstebanRey 11/19/2017 23:50'!addAddress: anAddress
	addresses add: anAddress .! !Party subclass: #Customer	instanceVariableNames: 'firstName lastName supplierId supplierType'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Customer methodsFor: 'initialization' stamp: 'HernanWilkinson 10/28/2016 13:26'!initialize	super initialize.	addresses := OrderedCollection new.! !!Customer methodsFor: 'importing' stamp: 'EstebanRey 11/6/2017 21:18'!importCustomers	"	self importCustomers	"	id importCustomers! !!Customer methodsFor: 'name' stamp: 'GUidoTripodi 11/18/2017 16:29'!persistInto: aSystem	aSystem persistCustomer: self.! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:25'!addresses	^ addresses! !!Customer methodsFor: 'addresses' stamp: 'HernanWilkinson 10/28/2016 13:27'!addAddress: anAddress 	addresses add: anAddress ! !!Customer methodsFor: 'identification' stamp: 'guidotripodi 11/19/2017 10:30'!supplierIdentificationNumber 	^supplierId.! !!Customer methodsFor: 'identification' stamp: 'guidotripodi 11/19/2017 10:29'!supplierType: anSupplierIdentificationType 	supplierType  := anSupplierIdentificationType .! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationNumber		^identificationNumber ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 16:13'!identificationType		^identificationType ! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Customer methodsFor: 'identification' stamp: 'HernanWilkinson 10/28/2016 13:10'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Customer methodsFor: 'identification' stamp: 'guidotripodi 11/19/2017 10:30'!supplierIdentificationNumber: anSupplierIdentificationNumber 	supplierId  := anSupplierIdentificationNumber .! !!Customer methodsFor: 'identification' stamp: 'guidotripodi 11/19/2017 10:30'!supplierType	^supplierType.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Customer class	instanceVariableNames: ''!!Customer class methodsFor: 'importing' stamp: 'HernanWilkinson 11/1/2016 08:39'!importCustomers	"	self importCustomers	"	| inputStream session newCustomer line |		inputStream := FileStream fileNamed: 'input.txt'.	session := DataBaseSession for: (Array 		with: (ClassMapping 			withDefaultTableNameFor: Address 			mappingAll: (Array 				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))) 		with: (ClassMapping 			withDefaultTableNameFor: Customer 			mappingAll: (Array 				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)))).	session open.	session beginTransaction.	line := inputStream nextLine.	[ line notNil ] whileTrue: [ 		(line beginsWith: 'C') ifTrue: [ | customerData |			customerData := line substrings: {$,}.			newCustomer := Customer new.			newCustomer firstName: customerData second.			newCustomer lastName: customerData third.			newCustomer identificationType: customerData fourth.			newCustomer identificationNumber: customerData fourth.			session persist: newCustomer ].				(line beginsWith: 'A') ifTrue: [ | addressData newAddress |			addressData := line substrings: { $, }.			newAddress := Address new.			newAddress streetName: addressData second.			newAddress streetNumber: addressData third asInteger. 			newAddress town: addressData fourth.			newAddress zipCode: addressData fifth asInteger.			newAddress province: addressData fourth.			newCustomer addAddress: newAddress. ].						line := inputStream nextLine. ].					session commit.		session close.				inputStream close.		! !ArrayedCollection subclass: #String	instanceVariableNames: ''	classVariableNames: 'AsciiOrder CSLineEnders CSNonSeparators CSSeparators CaseInsensitiveOrder CaseSensitiveOrder CrLfExchangeTable LowercasingTable Tokenish TypeTable UppercasingTable'	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!String commentStamp: '<historical>' prior: 0!A String is an indexed collection of Characters. Class String provides the abstract super class for ByteString (that represents an array of 8-bit Characters) and WideString (that represents an array of  32-bit characters).  In the similar manner of LargeInteger and SmallInteger, those subclasses are chosen accordingly for a string; namely as long as the system can figure out so, the String is used to represent the given string.Strings support a vast array of useful methods, which can best be learned by browsing and trying out examples as you find them in the code.Here are a few useful methods to look at...	String match:	String contractTo:String also inherits many useful methods from its hierarchy, such as	SequenceableCollection ,	SequenceableCollection copyReplaceAll:with:!!String methodsFor: '*Multilingual-TextConversion' stamp: 'KR 1/30/2006 21:49'!convertToEncoding: encodingName	^self convertToWithConverter: (TextConverter newForEncoding: encodingName).! !!String methodsFor: '*Multilingual-TextConversion' stamp: 'CamilloBruni 9/7/2011 16:18'!convertFromWithConverter: converter	| readStream c |	readStream := self readStream.	^ self class new: self size streamContents: [ :writeStream|		converter ifNil: [^ self].		[readStream atEnd] whileFalse: [			c := converter nextFromStream: readStream.			c				ifNotNil: [writeStream nextPut: c] 				ifNil: [^ writeStream contents]]].! !!String methodsFor: '*Multilingual-TextConversion' stamp: 'KR 1/30/2006 21:47'!convertFromEncoding: encodingName	^self convertFromWithConverter: (TextConverter newForEncoding: encodingName)! !!String methodsFor: '*Multilingual-TextConversion' stamp: 'CamilloBruni 9/7/2011 16:36'!convertToWithConverter: converter 	converter		ifNil: [^ self].	^ String new: self size streamContents: [:writeStream | 		converter 			nextPutAll: self toStream: writeStream;			emitSequenceToResetStateIfNeededOn: writeStream]! !!String methodsFor: '*Morphic-Base-Widgets' stamp: 'BenjaminVanRyseghem 2/21/2013 23:20'!listRenderOn: aCanvas atRow: aRow bounds: bounds color: color backgroundColor: backgroundColor from: aMorph	aCanvas		drawString: self		in: bounds		font: aMorph font		color: color! !!String methodsFor: '*Morphic-Base-Widgets' stamp: 'BenjaminVanRyseghem 2/12/2012 00:21'!widthToDisplayInList: aList	^ aList font widthOfStringOrText: self contents! !!String methodsFor: '*Morphic-Base-Widgets' stamp: 'BenjaminVanRyseghem 7/25/2012 11:43'!heightToDisplayInList: aList	^ aList font height! !!String methodsFor: '*Tool-FileList' stamp: 'CamilloBruni 9/7/2013 11:28'!asFileName	"Answer a String made up from the receiver that is an acceptable file 	name."	| string checkedString |	string := FileSystem disk checkName: self fixErrors: true.	checkedString := FilePathEncoder encode: string.	^ FilePathEncoder decode: checkedString! !!String methodsFor: '*network-url' stamp: 'SvenVanCaekenberghe 10/25/2013 14:21'!asUrl	^ self asZnUrl! !!String methodsFor: '*compression' stamp: 'yo 11/3/2004 19:24'!unzipped	| magic1 magic2 |	magic1 := (self at: 1) asInteger.	magic2 := (self at: 2) asInteger.	(magic1 = 16r1F and:[magic2 = 16r8B]) ifFalse:[^self].	^(GZipReadStream on: self) upToEnd! !!String methodsFor: '*compression' stamp: 'yo 11/3/2004 19:24'!lastIndexOfPKSignature: aSignature	"Answer the last index in me where aSignature (4 bytes long) occurs, or 0 if not found"	| a b c d |	a := aSignature first.	b := aSignature second.	c := aSignature third.	d := aSignature fourth.	(self size - 3) to: 1 by: -1 do: [ :i |		(((self at: i) = a)			and: [ ((self at: i + 1) = b)				and: [ ((self at: i + 2) = c)					and: [ ((self at: i + 3) = d) ]]])						ifTrue: [ ^i ]	].	^0! !!String methodsFor: '*compression' stamp: 'dgd 11/26/2005 21:19'!zipped	| stream gzstream |	stream := RWBinaryOrTextStream on: String new.	gzstream := GZipWriteStream on: stream.	gzstream nextPutAll: self.	gzstream close.	stream reset.	^ stream contents.! !!String methodsFor: '*compression' stamp: 'HenrikSperreJohansen 1/27/2010 18:07'!convertToSystemString	^LanguageEnvironment defaultSystemConverter convertToSystemString: self! !!String methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 1/14/2012 16:22'!stonOn: stonWriter	stonWriter writeString: self! !!String methodsFor: '*ston-core' stamp: 'SvenVanCaekenberghe 11/29/2012 16:27'!stonContainSubObjects 	^ false! !!String methodsFor: 'accessing' stamp: 'CamilloBruni 8/1/2012 16:04'!endsWithDigit	"Answer whether the receiver's final character represents a digit."	^ self size > 0 and: [self last isDigit]! !!String methodsFor: 'accessing' stamp: 'CamilloBruni 8/1/2012 16:09'!indexOfSubCollection: sub 	^ self		indexOfSubCollection: sub		startingAt: 1		ifAbsent: [0]! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:30'!byteAt: index	^self subclassResponsibility! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:31'!indexOf: aCharacter startingAt: start	(aCharacter isCharacter) ifFalse: [^ 0].	^ self class indexOfAscii: aCharacter asciiValue inString: self startingAt: start! !!String methodsFor: 'accessing' stamp: 'nice 7/27/2007 23:33'!findString: key startingAt: start caseSensitive: caseSensitive 	"Answer the index in this String at which the substring key first occurs,	at or beyond start. The match can be case-sensitive or not. If no match	is found, zero will be returned."		"IMPLEMENTATION NOTE: do not use CaseSensitiveOrder because it is broken for WideString	This is a temporary work around until Wide CaseSensitiveOrder search is fixed	Code should revert to:	caseSensitive		ifTrue: [^ self findSubstring: key in: self startingAt: start matchTable: CaseSensitiveOrder]		ifFalse: [^ self findSubstring: key in: self startingAt: start matchTable: CaseInsensitiveOrder]"			^caseSensitive		ifTrue: [			(self class isBytes and: [key class isBytes])				ifTrue: [self						findSubstring: key						in: self						startingAt: start						matchTable: CaseSensitiveOrder]				ifFalse: [WideString new						findSubstring: key						in: self						startingAt: start						matchTable: nil]]		ifFalse: [			(self class isBytes and: [key class isBytes])				ifTrue: [self						findSubstring: key						in: self						startingAt: start						matchTable: CaseInsensitiveOrder]				ifFalse: [WideString new						findSubstring: key						in: self						startingAt: start						matchTable: CaseInsensitiveOrder]]! !!String methodsFor: 'accessing' stamp: 'SeanDeNigris 4/28/2015 09:12'!skipAnySubstring: delimiters startingAt: start 	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."	| any this ind ii |	ii := start-1.	[(ii := ii + 1) <= self size] whileTrue: [ "look for char that does not match"		any := false.		delimiters do: [:delim |			delim isCharacter 				ifTrue: [(self at: ii) == delim ifTrue: [any := true]]				ifFalse: ["a substring"					delim size > (self size - ii + 1) ifFalse: "Here's where the one-off error was."						[ind := 0.						this := true.						delim do: [:dd | 							dd == (self at: ii+ind) ifFalse: [this := false].							ind := ind + 1].						this ifTrue: [ii := ii + delim size - 1.  any := true]]							ifTrue: [any := false] "if the delim is too big, it can't match"]].		any ifFalse: [^ ii]].	^ self size + 1! !!String methodsFor: 'accessing' stamp: 'nice 7/27/2007 22:58'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	| index |	index := self findString: sub startingAt: start.	index = 0 ifTrue: [^ exceptionBlock value].	^ index! !!String methodsFor: 'accessing' stamp: 'BenjaminVanRyseghem 11/24/2010 14:31'!typeTable	^ self class typeTable! !!String methodsFor: 'accessing' stamp: 'nice 11/16/2009 13:23'!lineCount	"Answer the number of lines represented by the receiver, where every line delimiter CR, LF or CRLF pair adds one line."	| lineCount |	lineCount := 0.	self lineIndicesDo: [:start :endWithoutDelimiters :end |		lineCount := lineCount + 1].	^lineCount! !!String methodsFor: 'accessing' stamp: 'ClementBera 7/26/2013 17:00'!findTokens: delimiters escapedBy: quoteDelimiters 	"Answer a collection of Strings separated by the delimiters, where  	delimiters is a Character or collection of characters. Two delimiters in a  	row produce an empty string (compare this to #findTokens, which  	treats sequential delimiters as one).  	 	The characters in quoteDelimiters are treated as quote characters, such  	that any delimiter within a pair of matching quoteDelimiter characters  	is treated literally, rather than as a delimiter.  	 	The quoteDelimiter characters may be escaped within a quoted string.  	Two sequential quote characters within a quoted string are treated as  	a single character.  	 	This method is useful for parsing comma separated variable strings for  	spreadsheet import and export."	| tokens rs activeEscapeCharacter ts char token delimiterChars quoteChars |	delimiterChars := (delimiters 		ifNil: [ '' ]		ifNotNil: [ delimiters ]) asString.	quoteChars := (quoteDelimiters 		ifNil: [ '' ]		ifNotNil: [ quoteDelimiters ]) asString.	tokens := OrderedCollection new.	rs := self readStream.	activeEscapeCharacter := nil.	ts := String new writeStream.	[ rs atEnd ] whileFalse: 		[ char := rs next.		activeEscapeCharacter 			ifNil: 				[ (quoteChars includes: char) 					ifTrue: [ activeEscapeCharacter := char ]					ifFalse: 						[ (delimiterChars includes: char) 							ifTrue: 								[ token := ts contents.								tokens add: token.								ts := String new writeStream ]							ifFalse: [ ts nextPut: char ] ] ]			ifNotNil: 				[ char == activeEscapeCharacter 					ifTrue: 						[ rs peek == activeEscapeCharacter 							ifTrue: [ ts nextPut: rs next ]							ifFalse: [ activeEscapeCharacter := nil ] ]					ifFalse: [ ts nextPut: char ] ] ].	token := ts contents.	(tokens isEmpty and: [ token isEmpty ]) ifFalse: [ tokens add: token ].	^ tokens! !!String methodsFor: 'accessing' stamp: 'yo 8/28/2002 16:45'!indexOf: aCharacter	aCharacter isCharacter ifFalse: [^ 0].	^ self class		indexOfAscii: aCharacter asciiValue		inString: self		startingAt: 1.! !!String methodsFor: 'accessing' stamp: 'SeanDeNigris 4/28/2015 11:36'!findString: substring	"Answer the index of substring within the receiver, starting at start. If 	the receiver does not contain substring, answer 0."	^self findString: substring startingAt: 1.! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findTokens: delimiters keep: keepers	"Answer the collection of tokens that result from parsing self.  The tokens are seperated by delimiters, any of a string of characters.  If a delimiter is also in keepers, make a token for it.  (Very useful for carriage return.  A sole return ends a line, but is also saved as a token so you can see where the line breaks were.)"	| tokens keyStart keyStop |	tokens := OrderedCollection new.	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self skipDelimiters: delimiters startingAt: keyStop.		keyStop to: keyStart-1 do: [:ii | 			(keepers includes: (self at: ii)) ifTrue: [				tokens add: (self copyFrom: ii to: ii)]].	"Make this keeper be a token"		keyStop := self findDelimiters: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!includesSubstring: aString caseSensitive: caseSensitive		^ (self findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0! !!String methodsFor: 'accessing' stamp: 'nice 11/16/2009 13:23'!lineNumber: anIndex	"Answer a string containing the characters in the given line number."	| lineCount |	lineCount := 0.	self lineIndicesDo: [:start :endWithoutDelimiters :end |		(lineCount := lineCount + 1) = anIndex ifTrue: [^self copyFrom: start to: endWithoutDelimiters]].	^nil! !!String methodsFor: 'accessing' stamp: 'NicolaiHess 10/6/2015 18:50'!includesSubstring: substring	^ substring isEmpty or: [ (self findString: substring startingAt: 1) > 0 ]! !!String methodsFor: 'accessing' stamp: 'SeanDeNigris 4/28/2015 09:01'!findAnySubstring: aCollection startingAt: start 	"Answer the index where an element of aCollection begins. If none are found, answer size + 1. aCollection is an Array of Strings or Characters."	^aCollection inject: 1 + self size into: [:min :searchTerm |		| ind |		ind := searchTerm isCharacter 			ifTrue: [self indexOf: searchTerm startingAt: start ifAbsent: [min]]			ifFalse: [self indexOfSubCollection: searchTerm startingAt: start ifAbsent: [min]].		min min: ind]! !!String methodsFor: 'accessing' stamp: 'CamilloBruni 2/8/2012 20:15'!lineNumberCorrespondingToIndex: anIndex	"Answer a lineNumber for the line at the given character position."	|lineNumber|		lineNumber := 0.		self lineIndicesDo: [:start :endWithoutDelimiters :end |		lineNumber := lineNumber + 1.		anIndex <= end ifTrue: [^lineNumber]].	^lineNumber! !!String methodsFor: 'accessing' stamp: 'SeanDeNigris 4/28/2015 11:36'!findString: substring startingAt: start 	"Answer the index of substring within the receiver, starting at start. If 	the receiver does not contain substring, answer 0."	^self findString: substring startingAt: start caseSensitive: true! !!String methodsFor: 'accessing' stamp: 'StephaneDucasse 2/23/2012 14:15'!indexOfFirstUppercaseCharacter	"Returns the index of the first Uppercase character.	'uouFauhZ ' indexOfFirstUppercaseCharacter2 -> 4	New implementation much faster than older one.	"	| size |	size := self size.	1 to: size do: [:i| 		(self at: i) isUppercase 			ifTrue: [^ i ]].	^ 0! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!startsWithDigit	"Answer whether the receiver's first character represents a digit"	^ self size > 0 and: [self first isDigit]! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:30'!byteAt: index put: value	^self subclassResponsibility! !!String methodsFor: 'accessing' stamp: 'MarcusDenker 8/26/2010 21:00'!lines    "Answer an array of lines composing this receiver without the line ending delimiters"    ^Array new: (self size // 60 max: 16)            streamContents: [:lines | self linesDo: [:aLine | lines nextPut: aLine]]! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!skipDelimiters: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that does NOT match one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.  Assumes the delimiters to be a non-empty string."	start to: self size do: [:i |		delimiters detect: [:delim | delim = (self at: i)]				ifNone: [^ i]].	^ self size + 1! !!String methodsFor: 'accessing' stamp: 'yo 11/3/2004 19:24'!findCloseParenthesisFor: startIndex	"assume (self at: startIndex) is $(.  Find the matching $), allowing parentheses to nest."	" '(1+(2-3))-3.14159' findCloseParenthesisFor: 1 "	" '(1+(2-3))-3.14159' findCloseParenthesisFor: 4 "	| pos nestLevel |	pos := startIndex+1.	nestLevel := 1.	[ pos <= self size ] whileTrue: [		(self at: pos) = $( ifTrue: [ nestLevel := nestLevel + 1 ].		(self at: pos) = $) ifTrue: [ nestLevel := nestLevel - 1 ].		nestLevel = 0 ifTrue: [ ^pos ].		pos := pos + 1.	].	^self size + 1! !!String methodsFor: 'accessing' stamp: 'SeanDeNigris 4/28/2015 11:35'!findLastOccurrenceOfString: substring startingAt: start 	"Answer the index of the last occurrence of substring within the receiver, starting at start. If 	the receiver does not contain substring, answer 0.  Case-sensitive match used."	| last now |	last := self findString: substring startingAt: start.	last = 0 ifTrue: [^ 0].	[last > 0] whileTrue:		[now := last.		last := self findString: substring startingAt: last + 1].	^ now! !!String methodsFor: 'accessing' stamp: 'CamilloBruni 9/5/2011 17:33'!findDelimiters: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that matches one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1."	start to: self size do: [:i |		delimiters do: [:delim | 			delim = (self at: i) 				ifTrue: [^ i]]].	^ self size + 1! !!String methodsFor: 'accessing' stamp: 'StephaneDucasse 2/23/2012 14:18'!wordBefore: anIndex 	| sep tok |	tok := false.	sep := anIndex.	[ sep > 0 and: [ (self at: sep) tokenish ] ] whileTrue: 		[ tok := true.		sep := sep - 1 ]. 	^ tok 		ifTrue: 			[ self 				copyFrom: sep + 1				to: anIndex ]		ifFalse: [ String new ]! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:30'!byteSize	^self subclassResponsibility! !!String methodsFor: 'accessing' stamp: 'md 5/26/2005 13:35'!string	^self! !!String methodsFor: 'accessing' stamp: 'BernardoContreras 3/19/2015 19:38'!allRangesOfSubstring: aSubstring	^ Array streamContents: [:s | | start subSize |		start := 1.		subSize := aSubstring size.		[start isZero]			whileFalse: [ start := self findString: aSubstring startingAt: start.				start > 0 					ifTrue: [s nextPut: (start to: start + subSize - 1).						start := start + subSize]]]! !!String methodsFor: 'accessing' stamp: 'ar 4/10/2005 17:13'!findTokens: delimiters	"Answer the collection of tokens that result from parsing self.  Return strings between the delimiters.  Any character in the Collection delimiters marks a border.  Several delimiters in a row are considered as just one separation.  Also, allow delimiters to be a single character."	| tokens keyStart keyStop separators |	tokens := OrderedCollection new.	separators := delimiters isCharacter 		ifTrue: [Array with: delimiters]		ifFalse: [delimiters].	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self skipDelimiters: separators startingAt: keyStop.		keyStop := self findDelimiters: separators startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'nice 11/16/2009 12:32'!lineCorrespondingToIndex: anIndex	"Answer a string containing the line at the given character position."	self lineIndicesDo: [:start :endWithoutDelimiters :end |		anIndex <= end ifTrue: [^self copyFrom: start to: endWithoutDelimiters]].	^''! !!String methodsFor: 'accessing' stamp: 'nice 11/16/2009 12:26'!linesDo: aBlock	"Execute aBlock with each line in this string. The terminating line delimiters CR, LF or CRLF pairs are not included in what is passed to aBlock"	self lineIndicesDo: [:start :endWithoutDelimiters :end |		aBlock value: (self copyFrom: start to: endWithoutDelimiters)]! !!String methodsFor: 'accessing' stamp: 'nice 1/19/2010 00:29'!lineIndicesDo: aBlock	"execute aBlock with 3 arguments for each line:	- start index of line	- end index of line without line delimiter	- end index of line including line delimiter(s) CR, LF or CRLF"		| cr lf start sz nextLF nextCR |	start := 1.	sz := self size.	cr := Character cr.	nextCR := self indexOf: cr startingAt: 1.	lf := Character lf.	nextLF := self indexOf: lf startingAt: 1.	[ start <= sz ] whileTrue: [		(nextLF = 0 and: [ nextCR = 0 ])			ifTrue: [ "No more CR, nor LF, the string is over"					aBlock value: start value: sz value: sz.					^self ].		(nextCR = 0 or: [ 0 < nextLF and: [ nextLF < nextCR ] ])			ifTrue: [ "Found a LF"					aBlock value: start value: nextLF - 1 value: nextLF.					start := 1 + nextLF.					nextLF := self indexOf: lf startingAt: start ]			ifFalse: [ 1 + nextCR = nextLF				ifTrue: [ "Found a CR-LF pair"					aBlock value: start value: nextCR - 1 value: nextLF.					start := 1 + nextLF.					nextCR := self indexOf: cr startingAt: start.					nextLF := self indexOf: lf startingAt: start ]				ifFalse: [ "Found a CR"					aBlock value: start value: nextCR - 1 value: nextCR.					start := 1 + nextCR.					nextCR := self indexOf: cr startingAt: start ]]]! !!String methodsFor: 'accessing' stamp: 'SeanDeNigris 4/28/2015 09:12'!findBetweenSubstrings: delimiters	"Answer the collection of String tokens that result from parsing self.  Tokens are separated by 'delimiters', which can be a collection of Strings, or a collection of Characters.  Several delimiters in a row are considered as just one separation."	| tokens keyStart keyStop |	tokens := OrderedCollection new.	keyStop := 1.	[keyStop <= self size] whileTrue:		[keyStart := self skipAnySubstring: delimiters startingAt: keyStop.		keyStop := self findAnySubstring: delimiters startingAt: keyStart.		keyStart < keyStop			ifTrue: [tokens add: (self copyFrom: keyStart to: (keyStop - 1))]].	^tokens! !!String methodsFor: 'accessing' stamp: 'ar 4/12/2005 16:31'!indexOf: aCharacter  startingAt: start  ifAbsent: aBlock	| ans |	(aCharacter isCharacter) ifFalse: [ ^ aBlock value ].	ans := self class indexOfAscii: aCharacter asciiValue inString: self  startingAt: start.	ans = 0		ifTrue: [ ^ aBlock value ]		ifFalse: [ ^ ans ]! !!String methodsFor: 'accessing' stamp: 'nice 7/27/2007 23:13'!findWordStart: key startingAt: start	| ind |	"HyperCard style searching.  Answer the index in self of the substring key, when that key is preceeded by a separator character.  Must occur at or beyond start.  The match is case-insensitive.  If no match is found, zero will be returned."	ind := start.	[ind := self findString: key startingAt: ind caseSensitive: false.	ind = 0 ifTrue: [^ 0].	"not found"	ind = 1 ifTrue: [^ 1].	"First char is the start of a word"	(self at: ind-1) isSeparator] whileFalse: [ind := ind + 1].	^ ind	"is a word start"! !!String methodsFor: 'accessing' stamp: 'SeanDeNigris 4/28/2015 11:34'!findTokens: delimiters includes: substring	"Divide self into pieces using delimiters.  Return the piece that includes substring anywhere in it.  Is case sensitive (say asLowercase to everything beforehand to make insensitive)."^ (self findTokens: delimiters) 	detect: [:str | (str includesSubstring: substring)] 	ifNone: [nil]! !!String methodsFor: 'accessing' stamp: 'yo 12/17/2002 16:56'!leadingCharRunLengthAt: index	| leadingChar |	leadingChar := (self at: index) leadingChar.	index to: self size do: [:i |		(self at: i) leadingChar ~= leadingChar ifTrue: [^ i - index].	].	^ self size - index + 1.! !!String methodsFor: '*UIManager-Support' stamp: 'CamilloBruni 8/30/2012 16:21'!displayProgressFrom: minVal to: maxVal during: workBlock 	"Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some Real Progress'	displayProgressFrom: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]]."	^ UIManager default 		displayProgress: self 		from: minVal 		to: maxVal 		during: workBlock! !!String methodsFor: '*UIManager-Support' stamp: 'MartinDias 12/19/2012 17:53'!displayProgressAt: aPoint from: minVal to: maxVal during: workBlock 	"Deprecated!! - Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some Real Progress'	displayProgressAt: Sensor cursorPoint	from: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]].HOW IT WORKS (Try this in any other language :-)Since your code (the last 2 lines in the above example) is in a block,this method gets control to display its heading before, and clean up the screen after, its execution.The key, though, is that the block is supplied with an argument,named 'bar' in the example, which will update the bar image every it is sent the message value: x, where x is in the from:to: range."	"deprecated use displayProgressFrom: minVal to: maxVal during: workBlock "	^UIManager default 		displayProgress: self		from: minVal 		to: maxVal 		during: workBlock! !!String methodsFor: '*Text-Core' stamp: 'JuanVuletich 10/12/2010 12:52'!encompassParagraph: anInterval	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.	Answer starts at the position following a cr (or eventually 1) and ends at a cr (or eventually at self size).	See also #encompassLine:"	| left right |	left := (self lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	right := (self indexOf: Character cr startingAt: (anInterval last max: anInterval first) ifAbsent: [self size]).	^left to: right! !!String methodsFor: '*Text-Core' stamp: 'JuanVuletich 10/11/2010 20:14'!endOfParagraphBefore: aNumber	"Return the index of the last Character cr before position aNumber, or zero if this is the first paragraph.	'ddd' endOfParagraphBefore: 3	'dd	d' endOfParagraphBefore: 4	"	^ self lastIndexOf: Character cr startingAt: aNumber - 1 ifAbsent: [ 0 ]! !!String methodsFor: '*Text-Core' stamp: 'yo 11/3/2004 19:24'!asStringOrText	"Answer this string."	^ self! !!String methodsFor: '*Text-Core' stamp: 'JuanVuletich 10/13/2010 09:26'!encompassLine: anInterval	"Return an interval that includes anInterval, and that comprises one or several whole paragraphs in the receiver.	Answer starts at the position following a cr (or eventually 1) and ends before a cr (or eventually at self size)	See also encompassParagraph:"	| left right |	left := (self lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	right := (self indexOf: Character cr startingAt: (anInterval last max: anInterval first) ifAbsent: [self size+1])-1.	^left to: right! !!String methodsFor: '*Text-Core' stamp: 'yo 11/3/2004 19:24'!asText	"Answer a Text whose string is the receiver."	^Text fromString: self! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase."	^ self copy asString translateToLowercase! !!String methodsFor: 'converting' stamp: 'CamilloBruni 9/5/2011 17:53'!asFourCode	| result |	self size = 4 		ifFalse: [^self error: 'must be exactly four characters'].			result := self inject: 0 into: [:val :each | 256 * val + each asciiValue ].	(result bitAnd: 16r80000000) = 0 		ifFalse: [ Error signal: 'cannot resolve fourcode' ].			(result bitAnd: 16r40000000) = 0 		ifFalse: [ ^ result - 16r80000000 ].	^ result! !!String methodsFor: 'converting' stamp: 'CamilloBruni 8/1/2012 16:17'!stemAndNumericSuffix	"Parse the receiver into a string-valued stem and a numeric-valued suffix."	"'Fred2305' stemAndNumericSuffix"	| stem suffix position |	stem := self.	suffix := 0.	position := 1.	[stem endsWithDigit and: [stem size > 1]] whileTrue:		[suffix :=  stem last digitValue * position + suffix.		position := position * 10.		stem := stem copyFrom: 1 to: stem size - 1].	^ Array with: stem with: suffix! !!String methodsFor: 'converting' stamp: 'HenrikNergaard 5/14/2016 10:47'!repeat: aNumber	"returns a new string concatenated by itself repeated n times		'abc' repeat: 3. 'abcabcabc'	"	aNumber < 0 ifTrue: [ self error: 'aNumber cannot be negative' ].		^ self class 		new: self size * aNumber 		streamContents: [ :stringStream |			1 to: aNumber do: [ :idx | stringStream nextPutAll: self ].		]! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!romanNumber	| value v1 v2 |	value := v1 := v2 := 0.	self reverseDo:		[:each |		v1 := #(1 5 10 50 100 500 1000) at: ('IVXLCDM' indexOf: each).		v1 >= v2			ifTrue: [value := value + v1]			ifFalse: [value := value - v1].		v2 := v1].	^ value! !!String methodsFor: 'converting' stamp: 'maxmattone 6/12/2015 11:13'!withoutPrefix: prefix	"Remove the given prefix, if present."	^(self beginsWith: prefix) ifTrue: [ self copyFrom: 1 + prefix size to: self size ] ifFalse: [ self ]! !!String methodsFor: 'converting' stamp: 'dew 9/13/2001 01:17'!asPluralBasedOn: aNumberOrCollection	"Append an 's' to this string based on whether aNumberOrCollection is 1 or of size 1."	^ (aNumberOrCollection = 1 or:		[aNumberOrCollection isCollection and: [aNumberOrCollection size = 1]])			ifTrue: [self]			ifFalse: [self, 's']! !!String methodsFor: 'converting' stamp: 'damiencassou 5/30/2008 11:45'!asUnsignedInteger	"Returns the first integer it can find or nil."	| start stream |	start := self findFirst: [ :char | char isDigit ].	start isZero ifTrue: [ ^ nil ].	stream := self readStream position: start - 1.	^ Integer readFrom: stream! !!String methodsFor: 'converting' stamp: 'SeanDeNigris 1/24/2011 23:20'!asWideString 	^ WideString from: self! !!String methodsFor: 'converting' stamp: 'MarcusDenker 8/15/2010 11:06'!asCamelCase       "Convert to CamelCase. Can be conveinient in conjunction with #asLegalSelector     	 'A man, a plan, a canal, panama' asCamelCase.       'A man, a plan, a canal, panama' asCamelCase asLegalSelector.       'Here 123should % be 6 the name6 of the method' asCamelCase.       'Here 123should % be 6 the name6 of the method' asCamelCase asLegalSelector."      ^ self class streamContents: [:stream |               self substrings do: [:sub |                       stream nextPutAll: sub capitalized]]! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!correctAgainst: wordList	"Correct the receiver: assume it is a misspelled word and return the (maximum of five) nearest words in the wordList.  Depends on the scoring scheme of alike:"	| results |	results := self correctAgainst: wordList continuedFrom: nil.	results := self correctAgainst: nil continuedFrom: results.	^ results! !!String methodsFor: 'converting' stamp: 'ar 4/10/2005 19:24'!asSymbol	"Answer the unique Symbol whose characters are the characters of the 	string."	^Symbol intern: self! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!onlyLetters	"answer the receiver with only letters"	^ self select:[:each | each isLetter]! !!String methodsFor: 'converting' stamp: 'yo 8/28/2002 15:14'!translateFrom: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	self class translate: self from: start to: stop table: table! !!String methodsFor: 'converting' stamp: 'monty 9/24/2016 23:44'!substrings	"Answer an array of non-empty substrings from the receiver separated by	one or more whitespace characters."	^ self substrings: CSSeparators! !!String methodsFor: 'converting' stamp: 'monty 9/25/2016 12:14'!substrings: separators	"Answer an array of non-empty substrings from the receiver separated by	one or more characters from the 'separators' argument collection."	| substrings substringStart |	substrings := (Array new: 10) writeStream.	1 to: self size do: [ :i | 		| nextChar |		nextChar := self at: i.		(separators includes: nextChar)			ifTrue: [				substringStart					ifNotNil: [						substrings nextPut: (self copyFrom: substringStart to: i - 1).						substringStart := nil ] ]			ifFalse: [ substringStart ifNil: [ substringStart := i ] ] ].	substringStart		ifNotNil: [ substrings nextPut: (self copyFrom: substringStart to: self size) ].	^ substrings contents! !!String methodsFor: 'converting' stamp: 'CamilloBruni 9/5/2011 16:16'!numericSuffix	"	'abc98' numericSuffix	'98abc' numericSuffix	"	^ self stemAndNumericSuffix last! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap := self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap! !!String methodsFor: 'converting' stamp: 'DamienPollet 8/1/2014 15:21'!asComment	"return this string, munged so that it can be treated as a comment in Smalltalk code.  Quote marks are added to the beginning and end of the string, and whenever a solitary quote mark appears within the string, it is doubled"	^String streamContents:  [ :str |		| quoteCount first |		str nextPut: $".			quoteCount := 0.		first := true.		self do: [ :char |			char = $"				ifTrue: [					first ifFalse: [						str nextPut: char.						quoteCount := quoteCount + 1 ] ]				ifFalse: [					quoteCount odd ifTrue: [						"add a quote to even the number of quotes in a row"						str nextPut: $" ].					quoteCount := 0.					str nextPut: char ].			first := false ]. 		quoteCount odd ifTrue: [			"check at the end"			str nextPut: $". ].		str nextPut: $".	].	! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!truncateWithElipsisTo: maxLength	"Return myself or a copy suitably shortened but with elipsis added"	^ self size <= maxLength		ifTrue:			[self]		ifFalse:			[(self copyFrom: 1 to: (maxLength - 3)), '...']	"'truncateWithElipsisTo:' truncateWithElipsisTo: 20"! !!String methodsFor: 'converting' stamp: 'CamilloBruni 9/5/2011 18:02'!withoutPeriodSuffix	"Return a copy of the receiver up to, but not including, the first period.  If the receiver's *first* character is a period, then just return the entire receiver. "	| likely |	likely := self copyUpTo: $..	^ likely size = 0		ifTrue: [ self ]		ifFalse: [ likely ]! !!String methodsFor: 'converting' stamp: 'laza 10/1/2004 09:55'!asInteger 	^self asSignedInteger! !!String methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/17/2013 09:48'!withSeparatorsCompacted	"Return a copy of the receiver with each sequence of whitespace (separator) 	characters replaced by a single space character"	self isEmpty ifTrue: [ ^ self ].	^ self class new: self size streamContents: [:stream | 		| lastBlank |		lastBlank := false.		self do: [ :eachChar | 			lastBlank 				ifTrue: [					(lastBlank := eachChar isSeparator)						ifFalse: [ stream nextPut: eachChar ] ] 				ifFalse: [					(lastBlank := eachChar isSeparator)						ifTrue: [ stream nextPut: $  ]						ifFalse: [ stream nextPut: eachChar ] ] ] ]	"' test ' withSeparatorsCompacted"	"' test test' withSeparatorsCompacted"	"'test  test		 ' withSeparatorsCompacted"! !!String methodsFor: 'converting' stamp: 'BernardoContreras 8/11/2014 19:12'!uncapitalized	"Return a copy with the first letter downShifted (in lower case)"		| answer |	self ifEmpty: [ ^ self copy ].	answer := self copy.	answer at: 1 put: answer first asLowercase.	^ answer! !!String methodsFor: 'converting' stamp: 'StephaneDucasse 4/23/2010 21:06'!asDateAndTime 	"Convert from UTC format" 			^ DateAndTime fromString: self! !!String methodsFor: 'converting' stamp: 'HenrikSperreJohansen 6/15/2010 15:20'!asByteString	"Convert the receiver into a ByteString, if possible"	"Do not raise an error if it's not possible, since my use case is usually one in which WideStrings may or may not have been mutated to something representable in a ByteString, and we mostly do this to save space if possible. If the percentage of such cases are small, it may be better to use isOctetString check first to avoid creating String instances"		^self asOctetString! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asDate	"Many allowed forms, see Date>>#readFrom:"	^ Date fromString: self! !!String methodsFor: 'converting' stamp: 'CamilloBruni 9/5/2011 17:56'!asHex	^ self class new: self size * 4 streamContents: [ :stream |		self do: [ :ch | stream nextPutAll: ch hex ]]! !!String methodsFor: 'converting' stamp: 'yo 8/28/2002 15:13'!translateWith: table	"translate the characters in the string by the given table, in place"	^ self translateFrom: 1 to: self size table: table! !!String methodsFor: 'converting' stamp: 'MarcusDenker 5/18/2013 15:44'!parseLiterals	^ self class compiler parseLiterals: self! !!String methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/17/2013 10:28'!withoutTrailingDigits	"Answer the portion of the receiver that precedes any leading series of digits and separators.	If the receiver consists entirely of digits and separators, return an empty string"	^ self trimRight: [ :char | char isDigit or: [ char isSeparator ] ]! !!String methodsFor: 'converting' stamp: 'DamienPollet 8/1/2014 15:22'!asUncommentedCode	"this string reprensent a commented code, let's uncomment it"		^String streamContents:  [ :str |				|doubleQuoteAlreadyFound|		doubleQuoteAlreadyFound := false.				self withoutQuoting do: [ :char |			char = $"				ifTrue: [ 					doubleQuoteAlreadyFound 	ifTrue: [ 							str nextPut: $" ].					doubleQuoteAlreadyFound := doubleQuoteAlreadyFound not.				]				ifFalse: [ 					str nextPut: char				]		 ]	]! !!String methodsFor: 'converting' stamp: 'HenrikNergaard 10/5/2015 17:25'!asValidSelector	"e.g. '234znak ::x43 åå) :2' asValidSelector = #v234znak:x43:v2"	^(((	$: join: (			(			$: split: (				self select: [ :char |					(char charCode < 128) and: [ 						char isAlphaNumeric or: [ 							char = $:							]						]					]			)		)  		select: [ :split | split isNotEmpty ]		thenCollect: [ :nonEmptyString |			nonEmptyString first isLetter				ifTrue: [ nonEmptyString uncapitalized ]				ifFalse: [ 'v' , nonEmptyString ]		]	)) ifEmpty: [ 'v' ]), ((self isNotEmpty and: [ self last = $: ]) ifTrue: [ ':' ] ifFalse: [ #() ]) )asSymbol! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!translateToUppercase	"Translate all characters to lowercase, in place"	self translateWith: UppercasingTable! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asDuration 	"convert from [nnnd]hh:mm:ss[.nanos] format. [] implies optional elements"  	^ Duration fromString: self ! !!String methodsFor: 'converting' stamp: 'CamilloBruni 9/5/2011 16:20'!surroundedBy: aString	^ self class streamContents: [ :s|		s nextPutAll: aString.		s nextPutAll: self.		s nextPutAll: aString ].! !!String methodsFor: 'converting' stamp: 'MarcusDenker 6/29/2017 12:24'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	(aNumber isNumber not or: [ aNumber < 1 ]) ifTrue: [self error: 'too narrow'].	^self class		new: self size * (aNumber + 1) // aNumber "provision for supplementary line breaks"		streamContents: [ :stream |			self lineIndicesDo: [ :start :endWithoutDelimiters :end |				| pastEnd lineStart |				pastEnd := endWithoutDelimiters + 1.				"eliminate spaces at beginning of line"				lineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [pastEnd]) min: pastEnd.				[| lineStop lineEnd spacePosition |				lineEnd := lineStop  := lineStart + aNumber min: pastEnd.				spacePosition := lineStart.				[spacePosition < lineStop] whileTrue: [					spacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [pastEnd].					spacePosition <= lineStop ifTrue: [lineEnd := spacePosition].				].				"split before space or before lineStop if no space"				stream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).				"eliminate spaces at beginning of next line"				lineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd ifAbsent: [pastEnd].				lineStart <= endWithoutDelimiters ]					whileTrue: [stream cr].				stream nextPutAll: (self copyFrom: pastEnd to: end) ] ]! !!String methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/17/2013 09:41'!withoutTrailingNewlines	"Return a copy of the receiver with any combination of cr/lf characters at the end removed"	^ self trimRight: [ :char | char = Character cr or: [ char = Character lf ] ]! !!String methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/17/2013 10:27'!withoutLeadingDigits	"Answer the portion of the receiver that follows any leading series of digits and separators.	If the receiver consists entirely of digits and separators, return an empty string"	^ self trimLeft: [ :char | char isDigit or: [ char isSeparator ] ]! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asUppercase	"Answer a String made up from the receiver whose characters are all 	uppercase."	^self copy asString translateToUppercase! !!String methodsFor: 'converting' stamp: 'ClementBera 7/26/2013 16:58'!correctAgainst: wordList continuedFrom: oldCollection	"Like correctAgainst:.  Use when you want to correct against several lists, give nil as the first oldCollection, and nil as the last wordList."	^ wordList 		ifNil: [ self correctAgainstEnumerator: nil					continuedFrom: oldCollection ]		ifNotNil: [ self correctAgainstEnumerator: [ :action | wordList do: action without: nil]					continuedFrom: oldCollection ]! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!contractTo: smallSize	"return myself or a copy shortened by ellipsis to smallSize"	| leftSize |	self size <= smallSize		ifTrue: [^ self].  "short enough"	smallSize < 5		ifTrue: [^ self copyFrom: 1 to: smallSize].    "First N characters"	leftSize := smallSize-2//2.	^ self copyReplaceFrom: leftSize+1		"First N/2 ... last N/2"		to: self size - (smallSize - leftSize - 3)		with: '...'"	'A clear but rather long-winded summary' contractTo: 18"! !!String methodsFor: 'converting' stamp: 'CamilloBruni 9/5/2011 16:15'!initialIntegerOrNil	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"	"	'234Whoopie' initialIntegerOrNil	'wimpy' initialIntegerOrNil	'234' initialIntegerOrNil	'2N' initialIntegerOrNil	'2' initialIntegerOrNil	'  89Ten ' initialIntegerOrNil	'78 92' initialIntegerOrNil	"	| firstNonDigit |	(self size = 0 or: [ self first isDigit not ]) 		ifTrue: [ ^ nil ].	firstNonDigit := (self findFirst: [ :m | m isDigit not ]).	firstNonDigit = 0 ifTrue: [ firstNonDigit := self size + 1 ].	^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber! !!String methodsFor: 'converting' stamp: 'NikoSchwarz 10/24/2009 10:19'!squeezeOutNumber	"Try to find a number somewhere in this string, as explained in Number>readFrom:"	^ Number squeezeNumberOutOfString: self! !!String methodsFor: 'converting' stamp: 'CamilloBruni 8/1/2012 16:18'!truncateTo: smallSize	"return myself or a copy shortened to smallSize."	^ self size <= smallSize		ifTrue:			[self]		ifFalse:			[self copyFrom: 1 to: smallSize]! !!String methodsFor: 'converting' stamp: 'BenComan 8/11/2014 10:04'!findSelector	"Dan's code for hunting down selectors with keyword parts; while this doesn't give a true parse, in most cases it does what we want, in where it doesn't, we're none the worse for it."	| sel possibleParens |	sel := self trimBoth.	sel := sel copyReplaceAll: '#' with: ''.	sel := sel copyReplaceAll: '[' with: ' [ '.	(sel includes: $:) ifTrue:		[sel := sel copyReplaceAll: ':' with: ': '.	"for the style (aa max:bb) with no space"		possibleParens := sel findTokens: Character separators.		sel := self class streamContents:			[:s | | level | level := 0.			possibleParens do:				[:token | | n |				(level = 0 and: [token endsWith: ':'])					ifTrue: [s nextPutAll: token]					ifFalse: [(n := token occurrencesOf: $( ) > 0 ifTrue: [level := level + n].							(n := token occurrencesOf: $[ ) > 0 ifTrue: [level := level + n].							(n := token occurrencesOf: $] ) > 0 ifTrue: [level := level - n].							(n := token occurrencesOf: $) ) > 0 ifTrue: [level := level - n]]]]].	sel isEmpty ifTrue: [^ nil].	sel isOctetString ifTrue: [sel := sel asOctetString].	Symbol hasInterned: sel ifTrue:		[:aSymbol | ^ aSymbol].	^ nil! !!String methodsFor: 'converting' stamp: 'marcus.denker 2/18/2009 16:15'!asSignedInteger 	"Returns the first signed integer it can find or nil."	| start stream |	start := self findFirst: [:char | char isDigit].	start isZero ifTrue: [^ nil].	stream := self readStream position: start - 1.	((stream position ~= 0) and: [stream peekBack = $-])		ifTrue: [stream back].	^ Integer readFrom: stream! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asString	"Answer this string."	^ self! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!translateToLowercase	"Translate all characters to lowercase, in place"	self translateWith: LowercasingTable! !!String methodsFor: 'converting' stamp: 'CamilloBruni 9/5/2011 17:53'!asByteArray	"Convert to a ByteArray with the ascii values of the string."	| b |	b := ByteArray new: self byteSize.	1 to: self size * 4 do: [:i |		b at: i put: (self byteAt: i)].	^ b.! !!String methodsFor: 'converting' stamp: 'HenrikSperreJohansen 6/15/2010 15:16'!asOctetString	"Convert the receiver into an octet string, if possible"	"(IE, I am a WideString containing only character with codePoints < 255, so all of them fit in a latin1-string)."	| string |	string := String new: self size.	1 to: self size do: [:i | string at: i put: (self at: i)].	^string! !!String methodsFor: 'converting' stamp: 'maxmattone 6/12/2015 11:13'!withoutSuffix: suffix	"Remove the given suffix, if present."	^(self endsWith: suffix) ifTrue: [ self copyFrom: 1 to: self size - suffix size ] ifFalse: [ self ]! !!String methodsFor: 'converting' stamp: 'yo 11/3/2004 19:24'!asTime	"Many allowed forms, see Time>>readFrom:"	^ Time fromString: self.! !!String methodsFor: 'converting' stamp: 'nice 1/5/2010 15:59'!keywords	"Answer an array of the keywords that compose the receiver."	| keywords |	keywords := Array streamContents:		[:kwds | | char kwd | kwd := (String new: 16) writeStream.		1 to: self size do:			[:i |			kwd nextPut: (char := self at: i).			char = $: ifTrue: 					[kwds nextPut: kwd contents.					kwd reset]].		(kwd position = 0) ifFalse: [kwds nextPut: kwd contents]].	(keywords size >= 1 and: [(keywords at: 1) = ':']) ifTrue:		["Has an initial keyword, as in #:if:then:else:"		keywords := keywords allButFirst].	(keywords size >= 2 and: [(keywords at: keywords size - 1) = ':']) ifTrue:		["Has a final keyword, as in #nextPut::andCR"		keywords := keywords copyReplaceFrom: keywords size - 1								to: keywords size with: {':' , keywords last}].	^ keywords! !!String methodsFor: 'converting' stamp: 'CamilloBruni 9/23/2012 23:18'!asHTMLString	"substitute the < & > into HTML compliant elements"	"'<a>' asHTMLString"	^ self class new: self size streamContents: [ :s| 		self do: [:c | s nextPutAll: c asHTMLString ]]! !!String methodsFor: 'converting' stamp: 'CamilloBruni 9/5/2011 16:20'!surroundedBySingleQuotes	"Answer the receiver with leading and trailing quotes.  "	^ self surroundedBy: ($' asString)! !!String methodsFor: 'converting' stamp: 'ClementBera 7/26/2013 16:58'!correctAgainstDictionary: wordDict continuedFrom: oldCollection	"Like correctAgainst:continuedFrom:.  Use when you want to correct against a dictionary."	^ wordDict 		ifNil: [ self correctAgainstEnumerator: nil					continuedFrom: oldCollection ]		ifNotNil: [ self correctAgainstEnumerator: [ :action | wordDict keysDo: action ]					continuedFrom: oldCollection ]! !!String methodsFor: 'converting' stamp: 'SvenVanCaekenberghe 1/17/2013 09:39'!withBlanksCondensed	"Return a copy of the receiver with leading/trailing blanks (separators) removed	 and consecutive white spaces (separators) condensed to the first one."	| trimmed lastBlank |	trimmed := self trimBoth.	^ String streamContents: [ :stream | 			lastBlank := false.			trimmed				do: [ :eachChar | 					(eachChar isSeparator and: [ lastBlank ])						ifFalse: [ stream nextPut: eachChar ].					lastBlank := eachChar isSeparator ] ]	" ' abc  d   ' withBlanksCondensed"! !!String methodsFor: '*Metacello-Core-scripting' stamp: 'dkh 7/16/2012 10:51'!execute: projectSpecBlock against: aScriptExecutor    aScriptExecutor executeString: self do: projectSpecBlock! !!String methodsFor: '*GT-InspectorExtensions-Core' stamp: 'JurajKubelka 3/28/2015 18:03'!gtDisplayOn: aStream	self printOn: aStream.! !!String methodsFor: '*GT-InspectorExtensions-Core' stamp: 'AndreiChis 10/23/2015 17:07'!gtInspectorTextIn: composite	<gtInspectorPresentationOrder: -10>	composite text		title: 'String';		display: [ self truncateWithElipsisTo: 100000 ]! !!String methodsFor: '*EpiceaBrowsers' stamp: 'MartinDias 4/14/2017 13:21'!asInstanceSideBehaviorName	^ (self splitOn: Character space) first! !!String methodsFor: '*GT-SUnitDebugger' stamp: 'AndreiChis 12/28/2015 20:22'!gtDebuggerSUnitPrint	^ self printString! !!String methodsFor: '*monticello' stamp: 'avi 2/4/2004 14:14'!extractNumber	^ ('0', self select: [:ea | ea isDigit]) asNumber! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22'!resolvePackageSpecsNamedForMetacelloMCVersion: aMetacelloMCVersion visited: visited ifAbsent: aBlock    ^ aMetacelloMCVersion        allPackagesForSpecs: {(aMetacelloMCVersion packageNamed: self ifAbsent: aBlock)}        visited: visited! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22'!addToMetacelloRepositories: aMetacelloRepositoriesSpec	| spec |	spec := 		(aMetacelloRepositoriesSpec project repositorySpec)			description: self;			yourself.	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec addMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22'!packageFileSpecFor: aMetacelloPackagesSpec	^(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22'!fetchRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doFetchRequiredFromArray: (Array with: self).! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22'!mergeIntoMetacelloRepositories: aMetacelloRepositoriesSpec	| spec |	spec := 		(aMetacelloRepositoriesSpec project repositorySpec)			description: self;			yourself.	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec mergeMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22'!removeFromMetacelloRepositories: aMetacelloRepositoriesSpec	aMetacelloRepositoriesSpec addMember: 		(aMetacelloRepositoriesSpec removeMember 			name: self;			yourself)! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22'!loadRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doLoadRequiredFromArray: (Array with: self).! !!String methodsFor: '*metacello-mc' stamp: 'dkh 6/8/2012 14:04:22'!recordRequiredForMetacelloMCVersion: aMetacelloMCVersion	^aMetacelloMCVersion doRecordRequiredFromArray: (Array with: self).! !!String methodsFor: '*Zinc-Character-Encoding-Core' stamp: 'SvenVanCaekenberghe 9/15/2014 11:48'!urlEncoded	"URL Encode the receiver and return the resulting String.	This is an encoding where characters that are illegal in a URL are escaped."    ^ ZnPercentEncoder new encode: self! !!String methodsFor: '*Zinc-Character-Encoding-Core' stamp: 'SvenVanCaekenberghe 9/15/2014 13:36'!utf8Encoded	"Produce a ByteArray encoding the receiver using UTF-8,	the recommended encoding for Strings, unless you know what you are doing."		" 'Les élèves français' utf8Encoded "		^ self encodeWith: #utf8! !!String methodsFor: '*Zinc-Character-Encoding-Core' stamp: 'SvenVanCaekenberghe 9/15/2014 11:48'!urlDecoded	"URL Decode the receiver and return the resulting String.	This is an encoding where characters that are illegal in a URL are escaped."    ^ ZnPercentEncoder new decode: self! !!String methodsFor: '*Zinc-Character-Encoding-Core' stamp: 'SvenVanCaekenberghe 9/15/2014 13:35'!asZnCharacterEncoder	"Return a ZnCharacterEncoder instance using the receiver as identifier"		" 'UTF-8' asZnCharacterEncoder "		^ ZnCharacterEncoder newForEncoding: self! !!String methodsFor: '*Zinc-Character-Encoding-Core' stamp: 'SvenVanCaekenberghe 9/15/2014 13:35'!encodeWith: encoding	"Produce a ByteArray that encodes the receiver, using a specified encoding.	Encoding is either a ZnCharacterEncoder instance or an identifier for one."		" 'Les élèves français' encodeWith: #utf8 "		^ encoding asZnCharacterEncoder encodeString: self! !!String methodsFor: 'printing' stamp: 'CamilloBruni 9/5/2011 17:17'!encodeDoublingQuoteOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream print: $'.	1 to: self size do: [:i |		aStream print: (x := self at: i).		x = $' ifTrue: [aStream print: x]].	aStream print: $'! !!String methodsFor: 'printing' stamp: 'yo 11/3/2004 19:24'!isLiteral	^true! !!String methodsFor: 'printing' stamp: 'yo 8/26/2002 22:58'!storeOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	| x |	aStream nextPut: $'.	1 to: self size do:		[:i |		aStream nextPut: (x := self at: i).		x = $' ifTrue: [aStream nextPut: x]].	aStream nextPut: $'! !!String methodsFor: 'printing' stamp: 'sd 7/8/2006 18:06'!printOn: aStream 	"Print inside string quotes, doubling inbedded quotes." 	self storeOn: aStream! !!String methodsFor: '*Morphic-Base-Pluggable Widgets' stamp: 'BenjaminVanRyseghem 2/12/2012 15:17'!beginsWith: aString fromList: aMorph	^ self trimBoth asLowercase beginsWith: aString! !!String methodsFor: 'testing' stamp: 'CamilloBruni 9/5/2011 17:20'!indexOfWideCharacterFrom: start to: end	"Return the index of the first wide character following anIndex"	"Implementation note: inline #anySatisfy: here for efficiency reasons"		start to: end do: [:ix | 		(self basicAt: ix) > 255 ifTrue: [ ^ix ]].	^ 0! !!String methodsFor: 'testing' stamp: 'ar 4/10/2005 16:23'!isByteString	"Answer whether the receiver is a ByteString"	^false! !!String methodsFor: 'testing' stamp: 'PabloHerrero 2/16/2015 17:13'!isPatternVariable	 ^self keywords anySatisfy: [:each | each first = $`]! !!String methodsFor: 'testing' stamp: 'PatrickBarroca 6/7/2010 02:06'!isAllAlphaNumerics	"whether the receiver is composed entirely of alphanumerics"	self do: [:c | c isAlphaNumeric ifFalse: [^ false]].	^ true! !!String methodsFor: 'testing' stamp: 'CamilloBruni 9/5/2011 17:21'!lastSpacePosition	"Answer the character position of the final space or other separator character in the receiver, and 0 if none	'fred the bear' lastSpacePosition	'ziggie' lastSpacePosition	'elvis ' lastSpacePosition	'wimpy  ' lastSpacePosition	'' lastSpacePosition	"	self size to: 1 by: -1 do:		[:i | ((self at: i) isSeparator) ifTrue: [^ i]].	^ 0! !!String methodsFor: 'testing' stamp: 'DamienPollet 3/25/2015 16:13'!isAsciiString	^ self allSatisfy: [ :each | each asciiValue <= 127 ]! !!String methodsFor: 'testing' stamp: 'ar 4/12/2005 19:52'!isWideString	"Answer whether the receiver is a WideString"	^false! !!String methodsFor: 'testing' stamp: 'ar 4/10/2005 16:49'!includesUnifiedCharacter	^false! !!String methodsFor: 'testing' stamp: 'HenrikSperreJohansen 6/15/2010 17:36'!hasWideCharacterFrom: start to: stop	"Return true if one of my character in the range does not fit in a single byte"		"Implementation note: inline #anySatisfy: here for efficiency reasons"	^(self indexOfWideCharacterFrom: start to: stop) ~= 0! !!String methodsFor: 'testing' stamp: 'yo 11/3/2004 19:24'!isString	^ true! !!String methodsFor: 'testing' stamp: 'StephaneDucasse 2/23/2012 14:23'!occursInWithEmpty: prefix caseSensitive: aBoolean 	"Answer whether the receiver begins with the given prefix string. 	The comparison is case-sensitive." 	| matchTable |	prefix isEmpty ifTrue: [ ^ true ].	self size < prefix size ifTrue: [ ^ false ].	matchTable := aBoolean 		ifTrue: [ CaseSensitiveOrder ]		ifFalse: [ CaseInsensitiveOrder ].	^ (self 		findSubstring: prefix		in: self		startingAt: 1		matchTable: matchTable) > 0! !!String methodsFor: 'testing' stamp: 'PavelKrivanek 8/12/2016 16:51'!isValidGlobalName	self ifEmpty: [ ^ false ].		"reserverd default names"	self = 'NameOfSubclass' ifTrue: [ ^ false ].	self = 'TNameOfTrait' ifTrue: [ ^ false ].		^ Character supportsNonASCII 			ifTrue: [ 			(self first isLetter 				and: [self first isUppercase]) 				and: [ self allSatisfy: [:character | 						character isAlphaNumeric or: [ character = $_ ]]]]				ifFalse: [ 			(self first between: $A and: $Z) and: [  				self allSatisfy: [:character |					(character between: $a and: $z) or: [					(character between: $A and: $Z) or: [ 					(character between: $0 and: $9) or: [					character = $_]]]]]]! !!String methodsFor: 'testing' stamp: 'StephaneDucasse 6/11/2010 12:37'!isAllDigits	"whether the receiver is composed entirely of digits and has at least one digit"	self do: [:c | c isDigit ifFalse: [^ false]].	self ifEmpty: [^false].       ^ true! !!String methodsFor: 'testing' stamp: 'ar 4/10/2005 23:25'!isOctetString	"Answer whether the receiver can be represented as a byte string. 	This is different from asking whether the receiver *is* a ByteString 	(i.e., #isByteString)"	1 to: self size do: [:pos |		(self at: pos) asInteger >= 256 ifTrue: [^ false].	].	^ true.! !!String methodsFor: 'testing' stamp: 'CamilloBruni 9/5/2011 17:31'!isLiteralSymbol	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type next last |	self flag: 'reuse a parser for this'.		i := self size.	i = 0 ifTrue: [^ false].	"TypeTable should have been origined at 0 rather than 1 ..."	ascii := (self at: 1) asciiValue.	type := self typeTable at: ascii ifAbsent: [^false].	type == #xLetter ifTrue: [		next := last := nil.		[i > 1]				whileTrue: 					[ascii := (self at: i) asciiValue.					type := self typeTable at: ascii ifAbsent: [^false].					(type == #xLetter or: [type == #xDigit or: [type == #xColon							and: [								next == nil									ifTrue: [last := #xColon. true] 									ifFalse: [last == #xColon and: [next ~~ #xDigit and: [next ~~ #xColon]]]]]])						ifFalse: [^ false].					next := type.					i := i - 1].			^ true].		type == #xBinary ifTrue: [^i = 1]. "Here we could extend to		^(2 to: i) allSatisfy: [:j |			ascii := (self at: j) asciiValue.			(self typeTable at: ascii ifAbsent: []) == #xBinary]"	type == #verticalBar ifTrue: [^i = 1].	^false! !!String methodsFor: 'testing' stamp: 'StephaneDucasse 2/23/2012 14:22'!beginsWithEmpty: prefix caseSensitive: aBoolean 	"Answer whether the receiver begins with the given prefix string. 	The comparison is case-sensitive." 	| matchTable |	prefix isEmpty ifTrue: [ ^ true ].	self size < prefix size ifTrue: [ ^ false ].	matchTable := aBoolean 		ifTrue: [ CaseSensitiveOrder ]		ifFalse: [ CaseInsensitiveOrder ].	^ (self 		findSubstring: prefix		in: self		startingAt: 1		matchTable: matchTable) = 1! !!String methodsFor: 'testing' stamp: 'yo 11/3/2004 19:24'!isAllSeparators	"whether the receiver is composed entirely of separators"	self do: [ :c | c isSeparator ifFalse: [ ^false ] ].	^true! !!String methodsFor: 'system primitives' stamp: 'ul 9/14/2009 02:59'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned."	| index c1 c2 |	matchTable == nil ifTrue: [		key size = 0 ifTrue: [^ 0].		start to: body size - key size + 1 do:			[:startIndex |			index := 1.				[(body at: startIndex+index-1)					= (key at: index)]					whileTrue:					[index = key size ifTrue: [^ startIndex].					index := index+1]].		^ 0	].	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index := 1.		[c1 := body at: startIndex+index-1.		c2 := key at: index.		((c1 leadingChar = 0 and: [ c1 asciiValue < matchTable size ]) 			ifTrue: [ matchTable at: c1 asciiValue + 1 ]			ifFalse: [ c1 asciiValue + 1 ]) = 			((c2 leadingChar = 0 and: [ c2 asciiValue < matchTable size ])				ifTrue: [ matchTable at: c2 asciiValue + 1 ]				ifFalse: [c2 asciiValue + 1 ]) ]			whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0! !!String methodsFor: 'system primitives' stamp: 'CamilloBruni 9/5/2011 17:19'!endsWithAColon 	"Answer whether the final character of the receiver is a colon		#fred: endsWithAColon	'fred' endsWithAColon	"	^ self size > 0 and: [self last == $:]! !!String methodsFor: 'system primitives' stamp: 'nice 11/1/2011 22:56'!numArgs 	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector. It is intended mostly for the assistance of spelling correction."	| firstChar numColons start ix |	self size = 0 ifTrue: [^ -1].	firstChar := self at: 1.	(firstChar isLetter or: [ firstChar = $_]) ifTrue:		["Fast reject if any chars are non-alphanumeric		NOTE: fast only for Byte things - Broken for Wide"		self class isBytes			ifTrue: [(self findSubstring: '~' in: self startingAt: 1 matchTable: Tokenish) > 0 ifTrue: [^ -1]]			ifFalse: [2 to: self size do: [:i | (self at: i) tokenish ifFalse: [^ -1]]].		"Fast colon count"		numColons := 0.  start := 1.		[(ix := self indexOf: $: startingAt: start) > 0]			whileTrue:				[(ix = start or: [(self at: start) isDigit]) ifTrue: [^-1].				numColons := numColons + 1.				start := ix + 1].		numColons = 0 ifTrue: [^ 0].		self last = $:			ifTrue: [^ numColons]			ifFalse: [^ -1]].	"Test case of binary selector, if self allSatisfy: #isSpecial (inlined for speed)"	1 to: self size do: [:i | (self at: i) isSpecial ifFalse: [^ -1]].	^1! !!String methodsFor: 'formatting' stamp: 'yo 11/3/2004 19:24'!withCRs	"Return a copy of the receiver in which backslash (\) characters have been replaced with carriage returns."	^ self collect: [ :c | c = $\ ifTrue: [ Character cr ] ifFalse: [ c ]].! !!String methodsFor: 'formatting' stamp: 'md 5/26/2005 13:34'!expandMacrosWith: anObject with: anotherObject 	^self 		expandMacrosWithArguments: (Array with: anObject with: anotherObject)! !!String methodsFor: 'formatting' stamp: 'md 5/26/2005 13:34'!expandMacrosWith: anObject 	^self expandMacrosWithArguments: (Array with: anObject)! !!String methodsFor: 'formatting' stamp: 'md 5/26/2005 13:34'!expandMacrosWith: anObject with: anotherObject with: thirdObject with: fourthObject 	^self expandMacrosWithArguments: (Array 				with: anObject				with: anotherObject				with: thirdObject				with: fourthObject)! !!String methodsFor: 'formatting' stamp: 'GabrielOmarCotelli 10/24/2015 16:31'!expandMacrosWithArguments: anArray	| readStream char index |	^ self class		new: self size		streamContents:			[ :newStream | 			readStream := self readStream.			[ readStream atEnd ]				whileFalse:					[ char := readStream next.					char == $<						ifTrue:							[ | nextChar |							nextChar := readStream next asUppercase.							nextChar == $R								ifTrue: [ newStream cr ].							nextChar == $T								ifTrue: [ newStream tab ].							nextChar == $N								ifTrue: [ newStream nextPutAll: OSPlatform current lineEnding ].							nextChar isDigit								ifTrue:									[ index := nextChar digitValue.									[ readStream atEnd or: [ (nextChar := readStream next asUppercase) isDigit not ] ]										whileFalse: [ index := index * 10 + nextChar digitValue ] ].							nextChar == $?								ifTrue:									[ | trueString falseString |									trueString := readStream upTo: $:.									falseString := readStream upTo: $>.									readStream position: readStream position - 1.									newStream										nextPutAll:											((anArray at: index)												ifTrue: [ trueString ]												ifFalse: [ falseString ]) ].							nextChar == $P								ifTrue: [ newStream nextPutAll: (anArray at: index) printString ].							nextChar == $S								ifTrue: [ newStream nextPutAll: (anArray at: index) ].							readStream skipTo: $> ]						ifFalse: [ newStream								nextPut:									(char == $%										ifTrue: [ readStream next ]										ifFalse: [ char ]) ] ] ]! !!String methodsFor: 'formatting' stamp: 'md 5/26/2005 13:34'!expandMacrosWith: anObject with: anotherObject with: thirdObject 	^self expandMacrosWithArguments: (Array 				with: anObject				with: anotherObject				with: thirdObject)! !!String methodsFor: 'formatting' stamp: 'md 5/26/2005 13:34'!expandMacros	^self expandMacrosWithArguments: #()! !!String methodsFor: 'formatting' stamp: 'SvenVanCaekenberghe 11/21/2012 09:31'!format: collection 	"Format the receiver by interpolating elements from collection, as in the following examples:  	'Today is {1}.' format: {Date today}.	'Today is {date}.' format: (Dictionary with: #date->Date today). 	'In {1} you can escape \{ by prefixing it with \\' format: {'strings'}.  "		^ self class new: self size streamContents: [ :result | | stream |		stream := self readStream.		[ stream atEnd ] whileFalse: [ | currentChar | 			(currentChar := stream next) == ${				ifTrue: [ | expression index | 					expression := stream upTo: $}.					index := Integer readFrom: expression ifFail: [ expression ].					result nextPutAll: (collection at: index) asString ]				ifFalse: [					currentChar == $\						ifTrue: [ stream atEnd ifFalse: [ result nextPut: stream next ] ]						ifFalse: [ result nextPut: currentChar ] ] ] ]! !!String methodsFor: '*Regex-Core' stamp: 'vb 4/11/09 21:56'!asRegex	"Compile the receiver as a regex matcher. May raise RxParser>>syntaxErrorSignal	or RxParser>>compilationErrorSignal.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."	^RxParser preferredMatcherClass for: (RxParser new parse: self)! !!String methodsFor: '*Regex-Core' stamp: 'vb 4/11/09 21:56'!prefixMatchesRegex: regexString	"Test if the receiver's prefix matches a regex.		May raise RxParser class>>regexErrorSignal or child signals.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."	^regexString asRegex matchesPrefix: self! !!String methodsFor: '*Regex-Core' stamp: 'vb 4/11/09 21:56'!copyWithRegex: rxString matchesTranslatedUsing: aBlock	^rxString asRegex		copy: self translatingMatchesUsing: aBlock! !!String methodsFor: '*Regex-Core' stamp: 'vb 4/11/09 21:56'!allRangesOfRegexMatches: rxString	^rxString asRegex matchingRangesIn: self! !!String methodsFor: '*Regex-Core' stamp: 'vb 4/11/09 21:56'!regex: rxString matchesDo: aBlock	^rxString asRegex matchesIn: self do: aBlock! !!String methodsFor: '*Regex-Core' stamp: 'vb 4/11/09 21:56'!prefixMatchesRegexIgnoringCase: regexString	"Test if the receiver's prefix matches a regex.		May raise RxParser class>>regexErrorSignal or child signals.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."	^regexString asRegexIgnoringCase matchesPrefix: self! !!String methodsFor: '*Regex-Core' stamp: 'vb 4/11/09 21:56'!copyWithRegex: rxString matchesReplacedWith: aString	^rxString asRegex		copy: self replacingMatchesWith: aString! !!String methodsFor: '*Regex-Core' stamp: 'vb 4/11/09 21:56'!regex: rxString matchesCollect: aBlock	^rxString asRegex matchesIn: self collect: aBlock! !!String methodsFor: '*Regex-Core' stamp: 'vb 4/11/09 21:56'!matchesRegex: regexString	"Test if the receiver matches a regex.  May raise RxParser>>regexErrorSignal or	child signals.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."	^regexString asRegex matches: self! !!String methodsFor: '*Regex-Core' stamp: 'EstebanLorenzano 8/17/2012 16:40'!search: aString	"compatibility method to make regexp and strings work polymorphicly"	^ aString includesSubstring: self! !!String methodsFor: '*Regex-Core' stamp: 'vb 4/11/09 21:56'!matchesRegexIgnoringCase: regexString	"Test if the receiver matches a regex.  May raise RxParser>>regexErrorSignal or	child signals.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."	^regexString asRegexIgnoringCase matches: self! !!String methodsFor: '*Regex-Core' stamp: 'vb 4/11/09 21:56'!allRegexMatches: rxString	^rxString asRegex matchesIn: self! !!String methodsFor: '*Regex-Core' stamp: 'vb 4/11/09 21:56'!asRegexIgnoringCase	"Compile the receiver as a regex matcher. May raise RxParser>>syntaxErrorSignal	or RxParser>>compilationErrorSignal.	This is a part of the Regular Expression Matcher package, (c) 1996, 1999 Vassili Bykov.	Refer to `documentation' protocol of RxParser class for details."	^RxParser preferredMatcherClass		for: (RxParser new parse: self)		ignoreCase: true! !!String methodsFor: '*Polymorph-Widgets' stamp: 'BenjaminVanRyseghem 6/24/2012 23:11'!treeRenderOn: aCanvas bounds: drawBounds color: drawColor font: aFont from: aMorph	aCanvas		drawString: self		in: drawBounds 		font: aMorph font		color: drawColor! !!String methodsFor: '*Polymorph-Widgets' stamp: 'BenjaminVanRyseghem 6/24/2012 23:28'!heightToDisplayInTree: aTree	^ aTree fontToUse height! !!String methodsFor: '*Polymorph-Widgets' stamp: 'BenjaminVanRyseghem 6/24/2012 22:42'!widthToDisplayInTree: aTree	^ aTree fontToUse widthOfStringOrText: self contents! !!String methodsFor: '*filesystem-core-converting' stamp: 'cwp 11/21/2009 11:30'!asPathWith: anObject 	^ anObject pathFromString: self! !!String methodsFor: '*filesystem-core-converting' stamp: 'SeanDeNigris 7/12/2012 08:45'!asFileReference	^ FileSystem disk referenceTo: self! !!String methodsFor: '*filesystem-core-converting' stamp: 'StephaneDucasse 2/9/2011 13:41'!asResolvedBy: aFileSystem	^ aFileSystem resolveString: self! !!String methodsFor: '*filesystem-core-converting' stamp: 'EstebanLorenzano 4/2/2012 11:43'!asPath	"convert myself to a path"	"Examples:		'.' asPath		'~/Desktop' asPath		'/home/foo' asPath		'../../foo.bar' asPath"	^ FileSystem disk resolve: self! !!String methodsFor: '*System-Localization' stamp: 'HilaireFernandes 5/14/2010 17:50'!translated"answer the receiver translated to the default language"	^ NaturalLanguageTranslator translate: self! !!String methodsFor: '*System-Localization' stamp: 'HilaireFernandes 5/6/2010 21:54'!translatedTo: localeID 	"answer the receiver translated to the given locale id"	^ NaturalLanguageTranslator translate: self toLocale: localeID! !!String methodsFor: '*OSWindow-Core' stamp: 'RonieSalgado 1/16/2014 16:18'!asUTF8Bytes	^ ZnUTF8Encoder new encodeString: self! !!String methodsFor: '*Slot' stamp: 'MarcusDenker 8/17/2016 13:14'!asSlotCollection	"Parse as slots. Use space, tab and cr as separators	Example: 	  'a b' asSlotCollection --> {a => Slot. b => Slot}	"	| whitespaces |	whitespaces := ByteString withAll: { Character space . Character tab . Character cr }.	^(self substrings: whitespaces) collect: [ :substring | substring asValidInstVarName asSlot ]! !!String methodsFor: '*Slot' stamp: 'MarcusDenker 6/2/2015 16:31'!isLegalClassName	"Answer whether aString is a legal  class name."	^ [Smalltalk classInstaller validateClassName: self asSymbol] on: Error do: [^ false] ! !!String methodsFor: '*Slot' stamp: 'BenjaminVanRyseghem 11/24/2010 14:41'!isLegalInstVarName	"Answer whether aString is a legal instance variable name."	^ ((self isLiteralSymbol) and: [(self includes: $:) not]) and:		[(self inviolateInstanceVariableNames includes:  self) not]! !!String methodsFor: '*Slot' stamp: 'MarcusDenker 11/6/2015 14:48'!asSlot	^ self asSymbol asSlot! !!String methodsFor: '*Slot' stamp: 'HenrikNergaard 12/2/2015 12:40'!asValidInstVarName	| validName |		validName := self select: [ :c | c isAlphaNumeric or: [ c == $_ ] ].		^validName first isDigit 		ifTrue: [ 'v' , validName ]		ifFalse: [ validName ]! !!String methodsFor: '*Slot' stamp: 'MarcusDenker 11/6/2015 14:48'!asClassVariable	^ self asSymbol asClassVariable! !!String methodsFor: '*Slot' stamp: 'BenjaminVanRyseghem 11/24/2010 14:41'!inviolateInstanceVariableNames	"Answer a list of instance variable names not to be used.  (Place holder for real list)"	^ #('thisContext' 'self')! !!String methodsFor: 'copying' stamp: 'yo 11/3/2004 19:24'!copyReplaceTokens: oldSubstring with: newSubstring 	"Replace all occurrences of oldSubstring that are surrounded	by non-alphanumeric characters"	^ self copyReplaceAll: oldSubstring with: newSubstring asTokens: true	"'File asFile Files File''s File' copyReplaceTokens: 'File' with: 'Snick'"! !!String methodsFor: 'copying' stamp: 'yo 11/3/2004 19:24'!deepCopy	"DeepCopy would otherwise mean make a copy of the character;  since 	characters are unique, just return a shallowCopy."	^self shallowCopy! !!String methodsFor: 'copying' stamp: 'HenrikNergaard 4/18/2016 14:43'!copyReplaceAll: oldSubstring with: newSubstring    "Answer a copy of the receiver in which all occurrences of oldSubstring have been replaced by newSubstring"    | idx |            self = oldSubstring ifTrue: [ ^ newSubstring copy ].    oldSubstring isEmpty ifTrue: [ ^ self copy ].    idx := 1.    ^ self class new: self size streamContents: [ :stream | | foundIdx |        [ (foundIdx := self findString: oldSubstring startingAt: idx) isZero ] whileFalse: [             stream                 next: (foundIdx - idx) putAll: self startingAt: idx;                nextPutAll: newSubstring.            idx := foundIdx + oldSubstring size ].        idx <= self size ifTrue: [             stream next: (self size - idx + 1) putAll: self startingAt: idx ] ]! !!String methodsFor: 'copying' stamp: 'CamilloBruni 5/25/2012 18:14'!padLeftTo: length with: char	^ (String new: (length - self size max: 0) withAll: char) , self.! !!String methodsFor: 'copying' stamp: 'AdrienBarreau 6/17/2010 10:17'!trimLeft: aBlock	"Trim characters satisfying the condition given in aBlock from the left side of the receiving string."		^ self trimLeft: aBlock right: [ :char | false ]! !!String methodsFor: 'copying' stamp: 'AdrienBarreau 6/17/2010 10:11'!trimBoth: aBlock	"Trim characters satisfying the condition given in aBlock from both sides of the receiving string."	^ self trimLeft: aBlock right: aBlock! !!String methodsFor: 'copying' stamp: 'CamilloBruni 9/5/2011 17:15'!trimLeft: aLeftBlock right: aRightBlock	"Trim characters satisfying the condition given in aLeftBlock from the left side and aRightBlock from the right sides of the receiving string."	| left right |	left := 1.	right := self size.		[ left <= right and: [ aLeftBlock value: (self at: left) ] ]		whileTrue: [ left := left + 1 ].			[ left <= right and: [ aRightBlock value: (self at: right) ] ]		whileTrue: [ right := right - 1 ].			^ self copyFrom: left to: right! !!String methodsFor: 'copying' stamp: 'MarcusDenker 1/18/2014 14:11'!copyReplaceAll: oldSubstring with: newSubstring asTokens: ifTokens	"Answer a copy of the receiver in which all occurrences of	oldSubstring have been replaced by newSubstring.	ifTokens (valid for Strings only) specifies that the characters	surrounding the recplacement must not be alphanumeric.		Bruce Simth,  must be incremented by 1 and not 	newSubstring if ifTokens is true.  See example below. "	| aString startSearch currentIndex endIndex |	aString := self.	startSearch := 1.	[(currentIndex := aString indexOfSubCollection: oldSubstring startingAt: startSearch)			 > 0]		whileTrue: 		[endIndex := currentIndex + oldSubstring size - 1.		(ifTokens not			or: [(currentIndex = 1					or: [(aString at: currentIndex-1) isAlphaNumeric not])				and: [endIndex = aString size					or: [(aString at: endIndex+1) isAlphaNumeric not]]])			ifTrue: [aString := aString					copyReplaceFrom: currentIndex					to: endIndex					with: newSubstring.				startSearch := currentIndex + newSubstring size]			ifFalse: [				ifTokens 					ifTrue: [startSearch := currentIndex + 1]					ifFalse: [startSearch := currentIndex + newSubstring size]]].	^ aString"Test case:	'test te string' copyReplaceAll: 'te' with: 'longone' asTokens: true   "! !!String methodsFor: 'copying' stamp: 'AdrienBarreau 6/17/2010 10:17'!trimLeft	"Trim separators from the left side of the receiving string."		^ self trimLeft: [ :char | char isSeparator ] ! !!String methodsFor: 'copying' stamp: 'CamilloBruni 8/30/2011 18:41'!trimmed	^ self trimBoth! !!String methodsFor: 'copying' stamp: 'AdrienBarreau 6/17/2010 10:17'!trimRight	"Trim separators from the right side of the receiving string."		^ self trimRight: [ :char | char isSeparator ]! !!String methodsFor: 'copying' stamp: 'CamilloBruni 9/7/2011 16:59'!trim	^ self trimBoth! !!String methodsFor: 'copying' stamp: 'MarcusDenker 6/24/2016 10:32'!trimLineSpaces	"Trim the spaces from the right side of each line. Useful for code"		^ self class streamContents: [ :str |		self lines 			do: [ :line | str nextPutAll: line trimRight]			separatedBy: [str cr]]		! !!String methodsFor: 'copying' stamp: 'AdrienBarreau 6/17/2010 10:10'!trimBoth	"Trim separators from both sides of the receiving string."		^ self trimBoth: [ :char | char isSeparator ]! !!String methodsFor: 'copying' stamp: 'CamilloBruni 5/25/2012 18:14'!padRightTo: length	^ self padRightTo: length with: Character space! !!String methodsFor: 'copying' stamp: 'CamilloBruni 7/2/2012 13:19'!padRightTo: length with: char	^ self, (String new: (length - self size max: 0) withAll: char)! !!String methodsFor: 'copying' stamp: 'CamilloBruni 5/25/2012 18:14'!padLeftTo: length	^ self padLeftTo: length with: Character space! !!String methodsFor: 'copying' stamp: 'AdrienBarreau 6/17/2010 10:17'!trimRight: aBlock	"Trim characters satisfying the condition given in aBlock from the right side of the receiving string."	^ self trimLeft: [ :char | false ] right: aBlock! !!String methodsFor: '*Text-Scanning' stamp: 'tpr 10/1/2013 17:44'!encodedCharSetAt: index	"return the character encoding in place at index; the actual EncodedCharSet, not just a number. A bad index is an Error"	^EncodedCharSet charsetAt: (self at: index) leadingChar! !!String methodsFor: '*Network-MIME' stamp: 'MarcusDenker 7/22/2014 13:19'!decodeMimeHeader	"See RFC 2047, MIME Part Three: Message Header Extension for Non-ASCII  	Text. Text containing non-ASCII characters is encoded by the sequence  	=?character-set?encoding?encoded-text?=  	Encoding is Q (quoted printable) or B (Base64), handled by  	Base64MimeConverter / RFC2047MimeConverter.	Thanks to Yokokawa-san, it works in m17n package.  Try the following:	'=?ISO-2022-JP?B?U1dJS0lQT1AvGyRCPUJDKyVpJXMlQRsoQi8=?= =?ISO-2022-JP?B?GyRCJVElRiUjJSobKEIoUGF0aW8p?=' decodeMimeHeader."	| input |	input := self readStream.	^String streamContents: [ :output | | temp |		[ output nextPutAll: (input upTo: $=).		"ASCII Text"		input atEnd ] whileFalse: 		[ (temp := input next) = $? 			ifTrue: 				[ | pos charset mimeEncoding mimeDecoder charsetStream  |				charset := input upTo: $?.				(charset isNil or: [ charset isEmpty ]) ifTrue: [ charset := 'LATIN-1' ].				mimeEncoding := (input upTo: $?) asUppercase.				temp := input upTo: $?.				"Skip final ="				input next.				pos := input position.				input skipSeparators.				"Delete spaces if followed by ="				input peek = $= ifFalse: [ input position: pos ]. 									charsetStream :=  String new writeStream.				mimeDecoder := mimeEncoding = 'B' 					ifTrue: [ Base64MimeConverter new ]					ifFalse: [ RFC2047MimeConverter new ].				mimeDecoder					mimeStream: temp readStream;					dataStream: charsetStream;					mimeDecode.				output nextPutAll: (charsetStream contents convertFromEncoding: charset).				]			ifFalse: 				[ output					nextPut: $=;					nextPut: temp ] ] ]! !!String methodsFor: '*Network-MIME' stamp: 'ar 7/22/2009 22:00'!base64Decoded	"Decode the receiver from base 64"	"'SGVsbG8gV29ybGQ=' base64Decoded"	^(Base64MimeConverter mimeDecode: self as: self class)! !!String methodsFor: '*Network-MIME' stamp: 'StephaneDucasse 9/1/2009 15:50'!base64Encoded	"Encode the receiver as base64"	"'Hello World' base64Encoded"	^(Base64MimeConverter mimeEncode: self readStream) contents! !!String methodsFor: '*Network-MIME' stamp: 'yo 11/3/2004 19:24'!decodeQuotedPrintable	"Assume receiver is in MIME 'quoted-printable' encoding, and decode it."  	^QuotedPrintableMimeConverter mimeDecode: self as: self class! !!String methodsFor: '*Network-MIME' stamp: 'SvenVanCaekenberghe 10/22/2013 12:35'!asMIMEType	^ self asZnMimeType! !!String methodsFor: '*ScriptingExtensions' stamp: 'CamilloBruni 5/8/2013 11:23'!asClassInEnvironment: anEnvironment ifAbsent: absentBlock	^  anEnvironment 			at: self asSymbol 			ifPresent: [ :aClass| 				self 					assert: aClass isBehavior 					description: [ self printString, ' is not a Class but an instance of a ', aClass class name ].				aClass ]			ifAbsent: absentBlock	! !!String methodsFor: '*ScriptingExtensions' stamp: 'CamilloBruni 5/8/2013 11:13'!asClass	"returns a global class with my name"	^ self asClassInEnvironment: Smalltalk globals! !!String methodsFor: '*ScriptingExtensions' stamp: 'CamilloBruni 5/8/2013 11:16'!asClassInEnvironment: anEnvironment	"I return class named after myself from anEnvironment"	^ self 		asClassInEnvironment: anEnvironment 		ifAbsent: [ NotFound signalFor: self in: anEnvironment  ]! !!String methodsFor: '*ScriptingExtensions' stamp: 'CamilloBruni 5/8/2013 11:24'!asClassIfAbsent: absentBlock	"returns a global class with my name"	^ self asClassInEnvironment: Smalltalk globals ifAbsent: absentBlock! !!String methodsFor: '*ScriptingExtensions' stamp: 'CamilloBruni 5/8/2013 12:03'!asClassIfPresent: presentBlock	"returns a global class with my name"	^ presentBlock cull: (self asClassIfAbsent: [ ^ nil ])! !!String methodsFor: 'streaming' stamp: 'monty 8/29/2016 21:11'!putOn: aStream	aStream nextPutAll: self! !!String methodsFor: '*SortFunctions-Core-comparing' stamp: 'SvenVanCaekenberghe 3/2/2017 12:50'!threeWayCompareTo: anotherObject	"Do a three-way comparison between the receiver and anotherObject, returning	-1 if self < anotherObject	0 if self = anotherObject	1 if self > anotherObject	This assumes a total order in accordance with the mathematical law of trichotomy.	See also:  http://en.wikipedia.org/wiki/Three-way_comparison"	^ self = anotherObject		ifTrue: [ 0 ]		ifFalse: [ self < anotherObject				ifTrue: [ -1 ]				ifFalse: [ 1 ] ]! !!String methodsFor: '*Graphics-Display Objects' stamp: 'yo 11/3/2004 19:24'!displayOn: aDisplayMedium at: aPoint 	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, using black-colored text."	self displayOn: aDisplayMedium at: aPoint textColor: Color black! !!String methodsFor: '*Graphics-Display Objects' stamp: 'CamilloBruni 8/1/2012 16:03'!displayOn: aDisplayMedium	"Display the receiver on the given DisplayMedium."	self displayOn: aDisplayMedium at: 0 @ 0! !!String methodsFor: '*Graphics-Display Objects' stamp: 'yo 11/3/2004 19:24'!displayAt: aPoint 	"Display the receiver as a DisplayText at aPoint on the display screen."	self displayOn: Display at: aPoint! !!String methodsFor: '*Graphics-Display Objects' stamp: 'FernandoOlivero 3/30/2011 14:48'!displayOn: aDisplayMedium at: aPoint textColor: aColor	"Show a representation of the receiver as a DisplayText at location aPoint on aDisplayMedium, rendering the text in the designated color"	aDisplayMedium getCanvas drawString: self from: 1 to: self size at: aPoint font: nil color: aColor! !!String methodsFor: '*Glamour-Morphic-Brick' stamp: 'AliakseiSyrel 2/12/2015 17:52'!asBrick	^ GLMLabelBrick new		text: self asString;		height: [ :b | b approximateHeight ]! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!asMetacelloVersionNumber	^MetacelloVersionNumber fromString: self! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setAuthorInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setAuthor: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setBlessingInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setBlessing: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setIncludesInMetacelloPackage: aMetacelloPackageSpec	aMetacelloPackageSpec setIncludes: { self }.! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/21/2012 18:06'!asMetacelloSemanticVersionNumber    ^ MetacelloSemanticVersionNumber fromString: self! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setDescriptionInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setDescription: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setTimestampInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setTimestampWithString: self! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setPackage: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setPackage: aString withString: self! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setAuthorInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setAuthorWithString: self! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!removeFromMetacelloPackages: aMetacelloPackagesSpec	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec removeMember 			name: self;			yourself)! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 11/17/2013 17:19'!setImportInVersionSpec: aMetacelloVersionSpec  aMetacelloVersionSpec setImport: {self}! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setProject: aString withInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setProject: aString withString: self! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setPostLoadDoItInMetacelloSpec: aMetacelloSpec    self asSymbol setPostLoadDoItInMetacelloSpec: aMetacelloSpec! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setTimestampInMetacelloVersion: aMetacelloVersionSpec	aMetacelloVersionSpec setTimestamp: 		(aMetacelloVersionSpec project valueHolderSpec			value: self;			yourself)! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setBlessingInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setBlessingWithString: self! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setRequiresInMetacelloPackage: aMetacelloPackageSpec	aMetacelloPackageSpec setRequires: { self }.! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setLoadsInMetacelloProject: aMetacelloPackageSpec	aMetacelloPackageSpec setLoads: { self }.! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!addToMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := 		(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec addMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!mergeIntoMetacelloPackages: aMetacelloPackagesSpec	| spec |	spec := 		(aMetacelloPackagesSpec project packageSpec)			file: self;			yourself.	aMetacelloPackagesSpec addMember: 		(aMetacelloPackagesSpec mergeMember 			name: spec name;			spec: spec;			yourself)! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setDescriptionInMetacelloConfig: aMetacelloConfig	aMetacelloConfig setDescriptionWithString: self! !!String methodsFor: '*Metacello-Core' stamp: 'dkh 6/5/2012 19:01:24'!setPreLoadDoItInMetacelloSpec: aMetacelloSpec    self asSymbol setPreLoadDoItInMetacelloSpec: aMetacelloSpec! !!String methodsFor: '*Alien-Core' stamp: 'eem 2/21/2008 15:45'!asAlien	| bs |	^(Alien newC: (bs := self byteSize) + 1)		replaceFrom: 1 to: bs with: self startingAt: 1! !!String methodsFor: 'private' stamp: 'yo 8/28/2002 15:22'!stringhash	^ self hash.! !!String methodsFor: 'private' stamp: 'yo 8/26/2002 22:53'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!String methodsFor: 'private' stamp: 'ClementBera 7/26/2013 16:59'!correctAgainstEnumerator: wordBlock continuedFrom: oldCollection	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."	| choices results maxChoices scoreMin |	scoreMin := self size // 2 min: 3.	maxChoices := 10.	oldCollection 		ifNil: [ choices := SortedCollection sortBlock: [ :x :y | x value > y value ] ]		ifNotNil: [ choices := oldCollection ].	wordBlock isNil		ifTrue:			[ results := OrderedCollection new.			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]		ifFalse:			[ wordBlock value: [ :word | | score |				(score := self alike: word) >= scoreMin ifTrue:					[ choices add: (Association key: word value: score).						(choices size >= maxChoices) ifTrue: [ scoreMin := (choices at: maxChoices) value] ] ].			results := choices ].	^ results! !!String methodsFor: '*Versionner-Core-Model' stamp: 'ChristopheDemarey 11/6/2012 15:24'!configurationBaseName	"Return the baseName for this configuration class name."		^ (self indexOfSubCollection: 'ConfigurationOf') = 0		ifTrue: [ self ]		ifFalse: [ self copyFrom: ('ConfigurationOf' size + 1) to: self size]! !!String methodsFor: 'encoding' stamp: 'ar 4/10/2005 17:18'!writeLeadingCharRunsOn: stream	| runLength runValues runStart leadingChar |	self isEmpty ifTrue: [^ self].	runLength := OrderedCollection new.	runValues := OrderedCollection new.	runStart := 1.	leadingChar := (self at: runStart) leadingChar.	2 to: self size do: [:index |		(self at: index) leadingChar = leadingChar ifFalse: [			runValues add: leadingChar.			runLength add: (index - runStart).			leadingChar := (self at: index) leadingChar.			runStart := index.		].	].	runValues add: (self last) leadingChar.	runLength add: self size + 1 -  runStart.	stream nextPut: $(.	runLength do: [:rr | rr printOn: stream. stream space].	stream skip: -1; nextPut: $).	runValues do: [:vv | vv printOn: stream. stream nextPut: $,].	stream skip: -1.! !!String methodsFor: '*TxText-Model' stamp: 'IgorStasenko 2/12/2014 14:01'!asTxModel	^ TxModel fromString: self! !!String methodsFor: '*NautilusCommon' stamp: 'monty 9/1/2016 00:26'!normalizedSelectorForComparison	"Returns a normalized version of the receiver without colons and in all lowercase.	Optimized for Nautlius"	| selectorString selectorStringSize normalizedSelectorString normalizedSelectorStringSize |	"asString to convert Symbols"	selectorString := self asString.	selectorStringSize := self size.	normalizedSelectorString := selectorString class new: selectorStringSize.	normalizedSelectorStringSize := 0.	"this inlined to:do: loop with direct string manipulation is faster than	using copyWithout:, which relies on reject:"	1 to: selectorStringSize do: [ :i | 		| nextChar |		(nextChar := selectorString at: i) == $:			ifFalse: [				normalizedSelectorString					at: (normalizedSelectorStringSize := normalizedSelectorStringSize + 1)					put: nextChar ] ].	"faster to use asLowercase on the entire string after instead of on chars	in the to:do: loop because of the bad Character>>#asLowercase implementation"	^ (normalizedSelectorStringSize < selectorStringSize		ifTrue: [ normalizedSelectorString first: normalizedSelectorStringSize ]		ifFalse: [ selectorString ]) asLowercase! !!String methodsFor: '*Morphic-Base' stamp: 'ClementBera 9/30/2013 10:48'!indentationIfBlank: aBlock 	"Answer the number of leading tabs in the receiver.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value."	| reader leadingTabs lastSeparator cr tab ch |	cr := Character cr.	tab := Character tab.	reader := self readStream.	leadingTabs := 0.	[ reader atEnd not and: [ (ch := reader next) = tab ] ] whileTrue: [ leadingTabs := leadingTabs + 1 ].	lastSeparator := leadingTabs + 1.	[ reader atEnd not and: [ ch isSeparator and: [ ch ~= cr ] ] ] whileTrue: 		[ lastSeparator := lastSeparator + 1.		ch := reader next ].	(lastSeparator = self size or: [ ch = cr ]) ifTrue: [ ^ aBlock value: leadingTabs ].	^ leadingTabs! !!String methodsFor: '*Morphic-Base' stamp: 'ar 4/10/2005 17:07'!asStringMorph 	"Answer the receiver as a StringMorph"	^ StringMorph contents: self"'bugs black blood' asStringMorph openInHand"! !!String methodsFor: '*Morphic-Base' stamp: 'ar 4/10/2005 17:07'!asMorph 	"Answer the receiver as a StringMorph"	^ StringMorph contents: self"'bugs black blood' asMorph openInHand"! !!String methodsFor: '*Morphic-Base' stamp: 'CamilloBruni 10/21/2012 23:37'!asDraggableMorph	^ self asStringMorph! !!String methodsFor: '*AST-Core-Parser' stamp: 'yo 11/3/2004 19:24'!asNumber 	"Answer the Number created by interpreting the receiver as the string 	representation of a number."	^Number readFromString: self! !!String methodsFor: '*RPackage-Core' stamp: 'MarcusDenker 4/30/2015 16:51'!asPackage	^ self asPackageIfAbsent: [ NotFound new messageText: 'There is no package named ', self; object: self; signal ] ! !!String methodsFor: '*RPackage-Core' stamp: 'TudorGirba 2/17/2015 09:01'!asPackageIfAbsent: aBlock	^ RPackageOrganizer default packageNamed: self ifAbsent: aBlock! !!String methodsFor: 'platform conventions' stamp: 'ul 11/23/2010 08:20'!withUnixLineEndings	"Assume the string is textual, and that CR, LF, and CRLF are all valid line endings.	Replace each occurence with a single LF."	(self includes: Character cr) ifFalse: [ ^self ].	(self includes: Character lf) ifFalse: [		^self translateWith: String crLfExchangeTable ].	^self withLineEndings: String lf! !!String methodsFor: 'platform conventions' stamp: 'CamilloBruni 10/20/2012 19:19'!withLineEndings: lineEndingString	| stream |		stream := nil.	self lineIndicesDo: [ :start :endWithoutDelimiters :end |		(stream isNil and: [ endWithoutDelimiters ~= end ]) ifTrue: [			(self copyFrom: endWithoutDelimiters + 1 to: end) = lineEndingString ifFalse: [				stream := WriteStream with: self copy.				stream position: start - 1 ]].		stream ifNotNil: [			stream next: endWithoutDelimiters - start + 1 putAll: self startingAt: start.			endWithoutDelimiters = end ifFalse: [				stream nextPutAll: lineEndingString ]]].	^stream		ifNil: [ self ]		ifNotNil: [ 			stream position = self size				ifTrue: [ stream originalContents ]				ifFalse: [ stream contents ]]! !!String methodsFor: 'platform conventions' stamp: 'ul 11/23/2010 08:19'!withSqueakLineEndings	"Assume the string is textual, and that CR, LF, and CRLF are all valid line endings.	Replace each occurence with a single CR."	(self includes: Character lf) ifFalse: [ ^self ].	(self includes: Character cr) ifFalse: [		^self translateWith: String crLfExchangeTable ].	^self withLineEndings: String cr! !!String methodsFor: 'platform conventions' stamp: 'EstebanLorenzano 5/22/2012 18:32'!withoutQuoting	"remove the initial and final quote marks, if present (and if matches nesting quotes)"	"'''h''' withoutQuoting"	| quote |	self size < 2 ifTrue: [ ^self ].	quote := self first.	(quote = self last and: [ quote = $' or: [ quote = $" ] ])		ifTrue: [ ^self copyFrom: 2 to: self size - 1 ]		ifFalse: [ ^self ].! !!String methodsFor: 'platform conventions' stamp: 'ul 11/22/2010 13:20'!withInternetLineEndings	"change line endings from CR's and LF's to CRLF's.  This is probably in prepration for sending a string over the Internet"		^self withLineEndings: String crlf! !!String methodsFor: 'comparing' stamp: 'yo 8/27/2002 14:15'!charactersExactlyMatching: aString	"Do a character-by-character comparison between the receiver and aString.  Return the index of the final character that matched exactly."	| count |	count := self size min: aString size.	1 to: count do: [:i | 		(self at: i) = (aString at: i) ifFalse: [			^ i - 1]].	^ count! !!String methodsFor: 'comparing' stamp: 'CamilloBruni 9/5/2011 17:52'!match: text	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters.	'*'			match: 'zort' true	'*baz'		match: 'mobaz' true	'*baz'		match: 'mobazo' false	'*baz*'		match: 'mobazo' true	'*baz*'		match: 'mozo' false	'foo*'		match: 'foozo' true	'foo*'		match: 'bozo' false	'foo*baz'	match: 'foo23baz' true	'foo*baz'	match: 'foobaz' true	'foo*baz'	match: 'foo23bazo' false	'foo'		match: 'Foo' true	'foo*baz*zort' match: 'foobazort' false	'foo*baz*zort' match: 'foobazzort' false	'*foo#zort'	match: 'afoo3zortthenfoo3zort' true	'*foo*zort'	match: 'afoodezortorfoo3zort' true"	^ self startingAt: 1 match: text startingAt: 1! !!String methodsFor: 'comparing' stamp: 'MarcusDenker 5/27/2014 17:28'!= aString 	"Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."		(aString isString and: [self size = aString size]) ifFalse: [^false].	^ (self compare: self with: aString collated: AsciiOrder) = 2! !!String methodsFor: 'comparing' stamp: 'DenisKudryashov 3/31/2017 10:59'!findSubstringViaPrimitive: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	<var: #key declareC: 'unsigned char *key'>	<var: #body declareC: 'unsigned char *body'>	<var: #matchTable declareC: 'unsigned char *matchTable'>	key size = 0 ifTrue: [^ 0].	(start max: 1) to: body size - key size + 1 do:		[:startIndex |		index := 1.			[(matchTable at: (body basicAt: startIndex+index-1) + 1)				= (matchTable at: (key basicAt: index) + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!String methodsFor: 'comparing' stamp: 'CamilloBruni 9/5/2011 17:46'!compare: string1 with: string2 collated: order	"	self assert: 'abc' = 'abc' asWideString.	self assert: 'abc' asWideString = 'abc'.	self assert: ((ByteArray with: 97 with: 0 with: 0 with: 0) asString ~= 'a000' asWideString).	self assert: ('a000' asWideString ~= (ByteArray with: 97 with: 0 with: 0 with: 0) asString).	self assert: ('abc' sameAs: 'aBc' asWideString).	self assert: ('aBc' asWideString sameAs: 'abc').	self assert: ((ByteArray with: 97 with: 0 with: 0 with: 0) asString sameAs: 'Abcd' asWideString) not.	self assert: ('a000' asWideString sameAs: (ByteArray with: 97 with: 0 with: 0 with: 0) asString) not.	"	(string1 isByteString and: [string2 isByteString]) ifTrue: [		^ ByteString compare: string1 with: string2 collated: order].     "Primitive does not fail properly right now"	^ String compare: string1 with: string2 collated: order! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!endsWithAnyOf: aCollection	aCollection do:[:suffix|		(self endsWith: suffix) ifTrue:[^true].	].	^false! !!String methodsFor: 'comparing' stamp: 'yo 11/3/2004 19:24'!alike: aString 	"Answer some indication of how alike the receiver is to the argument,  0 is no match, twice aString size is best score.  Case is ignored."	| i j k minSize bonus |	minSize := (j := self size) min: (k := aString size).	bonus := (j - k) abs < 2 ifTrue: [ 1 ] ifFalse: [ 0 ].	i := 1.	[(i <= minSize) and: [((super at: i) bitAnd: 16rDF)  = ((aString at: i) asciiValue bitAnd: 16rDF)]]		whileTrue: [ i := i + 1 ].	[(j > 0) and: [(k > 0) and:		[((super at: j) bitAnd: 16rDF) = ((aString at: k) asciiValue bitAnd: 16rDF)]]]			whileTrue: [ j := j - 1.  k := k - 1. ].	^ i - 1 + self size - j + bonus. ! !!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:38'!compare: aString 	"Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after.	The collation sequence is ascii with case differences ignored.	To get the effect of a <= b, but ignoring case, use (a compare: b) <= 2."	^self compare: aString caseSensitive: false! !!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:42'!compare: aString caseSensitive: aBool	"Answer a comparison code telling how the receiver sorts relative to aString:		1 - before		2 - equal		3 - after.	"	| map |	map := aBool ifTrue:[CaseSensitiveOrder] ifFalse:[CaseInsensitiveOrder].	^self compare: self with: aString collated: map! !!String methodsFor: 'comparing' stamp: 'CamilloBruni 9/5/2011 17:51'!howManyMatch: string 	"Count the number of characters that match up in self and aString."	| count shorterLength |		count := 0.	shorterLength := self size min: string size.	1 to: shorterLength do: [:index |		(self at: index) = (string at: index )			ifTrue: [ count := count + 1 ]].	^  count 		! !!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 17:35'!sameAs: aString 	"Answer whether the receiver sorts equal to aString. The 	collation sequence is ascii with case differences ignored."	^(self compare: aString caseSensitive: false) = 2! !!String methodsFor: 'comparing' stamp: 'lr 7/7/2006 11:21'!> aString 	"Answer whether the receiver sorts after aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) = 3! !!String methodsFor: 'comparing' stamp: 'ul 1/15/2011 13:54'!startingAt: keyStart match: text startingAt: textStart	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."		| anyMatch matchStart matchEnd i matchStr j ii jj |	i := keyStart.	j := textStart.		"Process consecutive *s and #s at the beginning."	anyMatch := false.	[ i <= self size and: [		(self at: i)			caseOf: {				[ $* ] -> [ 					anyMatch := true.					i := i + 1.					true ].				[ $# ] -> [					i := i + 1.					j := j + 1.					true ] }			otherwise: [ false ] ] ] whileTrue.	i > self size ifTrue: [		^j - 1 = text size or: [ "We reached the end by matching the character with a #."			anyMatch and: [ j <= text size ] "Or there was a * before the end." ] ].	matchStart := i.	"Now determine the match string"	matchEnd := self size.	(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue: [ matchEnd := ii-1 ].	(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue: [ matchEnd := matchEnd min: ii-1 ].	matchStr := self copyFrom: matchStart to: matchEnd.	"Now look for the match string"	[jj := text findString: matchStr startingAt: j caseSensitive: false.	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]		whileTrue:		["Found matchStr at jj.  See if the rest matches..."		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:			[^ true "the rest matches -- success"].		"The rest did not match."		anyMatch ifFalse: [^ false].		"Preceded by * -- try for a later match"		j := j+1].	^ false "Failed to find the match string"! !!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:39'!caseSensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case sensitive."	^(self compare: aString caseSensitive: true) <= 2! !!String methodsFor: 'comparing' stamp: 'md 5/11/2008 12:08'!hash	"#hash is implemented, because #= is implemented"	"ar 4/10/2005: I had to change this to use ByteString hash as initial 	hash in order to avoid having to rehash everything and yet compute	the same hash for ByteString and WideString."	^ self class stringHash: self initialHash: ByteString hash! !!String methodsFor: 'comparing' stamp: 'lr 7/7/2006 11:20'!<= aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is simple ascii (with case differences)."		^ (self compare: self with: aString collated: AsciiOrder) <= 2! !!String methodsFor: 'comparing' stamp: 'SeanDeNigris 1/24/2011 23:35'!findIn: body startingAt: start matchTable: matchTable		^ self findSubstringViaPrimitive: self in: body startingAt: start matchTable: matchTable! !!String methodsFor: 'comparing' stamp: 'lr 7/7/2006 11:21'!>= aString 	"Answer whether the receiver sorts after or equal to aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) >= 2! !!String methodsFor: 'comparing' stamp: 'ar 4/10/2005 16:39'!caseInsensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case insensitive."	^(self compare: aString caseSensitive: false) <= 2! !!String methodsFor: 'comparing' stamp: 'CamilloBruni 9/5/2011 17:49'!endsWith: suffix	"Answer whether the tail end of the receiver is the same as suffix.	The comparison is case-sensitive. 	'Elvis' endsWith: 'vis'	"		| extra |	(extra := self size - suffix size) < 0 		ifTrue: [^ false].	^ (self findString: suffix startingAt: extra + 1) > 0! !!String methodsFor: 'comparing' stamp: 'lr 7/7/2006 11:19'!< aString 	"Answer whether the receiver sorts before aString.	The collation order is simple ascii (with case differences)."	^ (self compare: self with: aString collated: AsciiOrder) = 1! !!String methodsFor: '*Metacello-Core-version comparison' stamp: 'dkh 6/21/2012 20:44'!metacelloSemanticIntegerLessThanSelf: anInteger    "integer version components are always '>' string component"    ^ true! !!String methodsFor: '*Metacello-Core-version comparison' stamp: 'dkh 6/21/2012 20:43'!metacelloSemanticStringLessThanSelf: aString    ^ aString < self! !!String methodsFor: '*Metacello-Core-version comparison' stamp: 'dkh 6/5/2012 19:01:24'!metacelloVersionComponentLessThan: aMetacelloVersonComponent	^aMetacelloVersonComponent metacelloStringLessThanSelf: self! !!String methodsFor: '*Metacello-Core-version comparison' stamp: 'dkh 6/5/2012 19:01:24'!metacelloIntegerLessThanSelf: anInteger	"integer version components are always '>' string component"	^false! !!String methodsFor: '*Metacello-Core-version comparison' stamp: 'dkh 6/5/2012 19:01:24'!metacelloStringLessThanSelf: aString	^aString < self! !!String methodsFor: '*Metacello-Core-version comparison' stamp: 'dkh 6/21/2012 20:43'!metacelloSemanticVersionComponentLessThan: aMetacelloVersonComponent    ^ aMetacelloVersonComponent metacelloSemanticStringLessThanSelf: self! !!String methodsFor: '*zinc-resource-meta-core' stamp: 'SvenVanCaekenberghe 3/16/2013 20:23'!addedToZnUrl: url	| segments |	segments := self findTokens: '/'.	^ url withPathSegments: segments! !!String methodsFor: '*zinc-resource-meta-core' stamp: 'SvenVanCaekenberghe 1/4/2011 19:47'!asZnMimeType	^ ZnMimeType fromString: self! !!String methodsFor: '*zinc-resource-meta-core' stamp: 'SvenVanCaekenberghe 1/4/2011 13:03'!asZnUrl	^ ZnUrl fromString: self! !!String methodsFor: '*files' stamp: 'CamilloBruni 9/7/2013 11:28'!asVmPathName	^ FilePathEncoder encode: self! !!String methodsFor: '*libgit-core' stamp: ' 10/26/2017 14:08:21'!asLGitExternalString	| data |	data := ExternalData		fromHandle: (ExternalAddress allocate: self size + 1)		type: ExternalType char asPointerType.	LibC memCopy: self to: data size: self size.	data getHandle byteAt: self size + 1 put: 0.	^ data! !!String methodsFor: 'splitjoin' stamp: 'CamilloBruni 9/23/2012 23:21'!join: aCollection 	"'*' join: #('WWWWW' 'W  EW' 'zzzz')		->  'WWWWW*W  EW*zzzz' "	^ self class new: (aCollection size * self size) streamContents: [:stream | 			aCollection				do: [:each | stream nextPutAll: each asString] 				separatedBy: [stream nextPutAll: self]]! !!String methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 8/28/2015 16:17'!asFFILibrary 	^ FFIUnknownLibrary name: self! !!String methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 8/14/2015 11:45'!asExternalTypeOn: generator	^ generator resolveType: self! !!String methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 3/22/2016 16:17'!packToArity: arity	"WARNING: Here applies the same rules as in ByteArray>>#rollToArity:, check there!!"	arity = 1 ifTrue: [ ^ self ].	self error: 'Use ExternalAddress instead!!'! !!String methodsFor: '*Network-UUID' stamp: 'SeanDeNigris 4/24/2015 12:30'!asAlphaNumeric: totalSize extraChars: additionallyAllowed mergeUID: minimalSizeOfRandomPart 	"Generates a String with unique identifier ( UID ) qualities, the difference to a	 UUID is that its beginning is derived from the receiver, so that it has a meaning	 for a human reader.	 Answers a String of totalSize, which consists of 3 parts	 1.part: the beginning of the receiver only consisting of		a-z, A-Z, 0-9 and extraChars in Collection additionallyAllowed ( which can be nil )	 2.part: a single _	 3.part: a ( random ) UID of size >= minimalSizeOfRandomPart consisting of		a-z, A-Z, 0-9	 Starting letters are capitalized. 	 TotalSize must be at least 1.	 Exactly 1 occurrence of $_ is guaranteed ( unless additionallyAllowed includes $_ ).	 The random part has even for small sizes good UID qualitites for many practical purposes.	 If only lower- or uppercase letters are demanded, simply convert the answer with	 say #asLowercase. The probability of a duplicate will rise only moderately ( see below ).	 Example: 		size of random part = 10		in n generated UIDs the chance p of having non-unique UIDs is			n = 10000 ->  p < 1e-10		if answer is reduced to lowerCase: p < 1.4 e-8			n = 100000 -> p < 1e-8		at the bottom is a snippet for your own calculations  		Note: the calculated propabilites are theoretical,			for the actually used random generator they may be much worse"	| stream out sizeOfFirstPart index ascii ch skip array random |	totalSize > minimalSizeOfRandomPart ifFalse: [ self errorOutOfBounds ].	stream := self readStream.	out :=  (String new: totalSize) writeStream.	index := 0.	skip := true.	sizeOfFirstPart := totalSize - minimalSizeOfRandomPart - 1.	[ stream atEnd or: [ index >= sizeOfFirstPart ] ] whileFalse: 		[ (((ascii := (ch := stream next) asciiValue) between: 65 and: 90) or: 			[ (ascii between: 97 and: 122) or: 				[ ch isDigit or: [ additionallyAllowed notNil and: [ additionallyAllowed includes: ch ] ] ] ]) 			ifTrue: 				[ skip 					ifTrue: [ out nextPut: ch asUppercase ]					ifFalse: [ out nextPut: ch ].				index := index + 1.				skip := false ]			ifFalse: [ skip := true ] ].	out nextPut: $_.	array := Array new: 62.	1 		to: 26		do: 			[ :i | 			array 				at: i				put: (i + 64) asCharacter.			array 				at: i + 26				put: (i + 96) asCharacter ].	53 		to: 62		do: 			[ :i | 			array 				at: i				put: (i - 5) asCharacter ].	random := UUIDGenerator default randomGenerator.	totalSize - index - 1 timesRepeat: [ out nextPut: (array atRandom: random) ].	^ out contents	"	calculation of probability p for failure of uniqueness in n UIDs		Note: if answer will be converted to upper or lower case replace 62 with 36	| n i p all |	all := 62 raisedTo: sizeOfRandomPart.	i := 1.	p := 0.0 .	n := 10000.	[ i <= n ]	whileTrue: [		p := p + (( i - 1 ) / all ).		i := i + 1 ].	p   	approximation formula: n squared / ( 62.0 raisedTo: sizeOfRandomPart ) / 2 	"	"'Crop SketchMorphs and Grab Screen Rect to JPG' 			asAlphaNumeric: 31 extraChars: nil mergeUID: 10  	 			'CropSketchMorphsAndG_iOw94jquN6'	 'Monticello' 			asAlphaNumeric: 31 extraChars: nil mergeUID: 10    				'Monticello_kp6aV2l0IZK9uBULGOeG' 	 'version-', ( '1.1.2' replaceAll: $. with: $- )			asAlphaNumeric: 31 extraChars: #( $- ) mergeUID: 10    				'Version-1-1-2_kuz2tMg2xX9iRLDVR'"! !!String methodsFor: '*10Pines-C17-1' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!String class	instanceVariableNames: ''!!String class methodsFor: 'formatting' stamp: 'md 6/5/2005 07:49'!expandMacro: macroType argument: argument withExpansions: expansions 	macroType = $s ifTrue: [^expansions at: argument].	macroType = $p ifTrue: [^(expansions at: argument) printString].	macroType = $n ifTrue: [^String cr].	macroType = $t ifTrue: [^String tab].	self error: 'unknown expansion type'! !!String class methodsFor: 'accessing' stamp: 'ul 11/23/2010 08:17'!crLfExchangeTable	^CrLfExchangeTable! !!String class methodsFor: 'accessing' stamp: 'BenjaminVanRyseghem 11/24/2010 14:39'!typeTable	TypeTable ifNil: [self initializeTypeTable].	^ TypeTable! !!String class methodsFor: '*Spec-Inspector' stamp: 'SvenVanCaekenberghe 3/14/2014 10:34'!inspectorClass	^ EyeStringInspector! !!String class methodsFor: '*Polymorph-Widgets-Themes' stamp: 'DenisKudryashov 11/4/2016 13:37'!systemIconName	^ #stringIcon! !!String class methodsFor: '*UnifiedFFI' stamp: 'EstebanLorenzano 8/17/2015 13:55'!asExternalTypeOn: generator 	^ generator resolveType: #FFIExternalString! !!String class methodsFor: '*Tools' stamp: 'SeanDeNigris 5/28/2013 17:43'!canonicalArgumentName	^ 'aString'.! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!lf	"Answer a string containing a single carriage return character."	^ self with: Character lf! !!String class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 12/4/2014 17:10'!loremIpsum	"Return a constant string with one paragraph of text, the famous Lorem ipsum filler text.	The result is pure ASCII (Latin words) and contains no newlines."		^ 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.'! !!String class methodsFor: 'instance creation' stamp: 'SheridanMahoney 11/17/2009 13:27'!new: sizeRequested 	"Answer an instance of this class with the number of indexable	variables specified by the argument, sizeRequested."		self == String 		ifTrue:[^ByteString new: sizeRequested]		ifFalse:[^self basicNew: sizeRequested].! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!crlf	"Answer a string containing a carriage return and a linefeed."	^ self with: Character cr with: Character lf! !!String class methodsFor: 'instance creation' stamp: 'ar 4/10/2005 16:24'!fromByteArray: aByteArray	^ aByteArray asString! !!String class methodsFor: 'instance creation' stamp: 'StephaneDucasse 2/13/2010 12:19'!empty	"A canonicalized empty String instance."	^ ''! !!String class methodsFor: 'instance creation' stamp: 'dc 2/12/2007 10:47'!space	"Answer a string containing a single space character."	^ self with: Character space! !!String class methodsFor: 'instance creation' stamp: 'ar 4/12/2005 17:34'!with: aCharacter	| newCollection |	aCharacter asInteger < 256		ifTrue:[newCollection := ByteString new: 1]		ifFalse:[newCollection := WideString new: 1].	newCollection at: 1 put: aCharacter.	^newCollection! !!String class methodsFor: 'instance creation' stamp: 'SvenVanCaekenberghe 6/14/2013 13:42'!readFrom: inStream	"Answer an instance of me that is determined by reading the stream, 	inStream. Embedded double quotes become the quote Character."	| char done |	^ self streamContents: [ :outStream | 		"go to first quote"		inStream skipTo: $'.		done := false.		[ done or: [ inStream atEnd ] ]			whileFalse: [ 				char := inStream next.				char = $'					ifTrue: [ 						char := inStream next.						char = $'							ifTrue: [ outStream nextPut: char ]							ifFalse: [ done := true ] ]					ifFalse: [ outStream nextPut: char ] ] ]! !!String class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 13:29'!value: anInteger	^ self with: (Character value: anInteger).! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!crlfcrlf	^self crlf , self crlf.! !!String class methodsFor: 'instance creation' stamp: 'monty 8/29/2016 08:19'!loremIpsum: size	"Return a mostly random multi-paragraph filler string of the specified size.	The result is pure ASCII, uses CR for newlines and ends with a dot and newline."		"self loremIpsum: 2048"		| words out |	words := (self loremIpsum findTokens: ' ,.') collect: #asLowercase.	(out := LimitedWriteStream on: (self new: size))		limit: size - 2;		limitBlock: [			^ out originalContents 				at: size - 1 put: $.; 				at: size put: Character cr; 				yourself ].	[ 		out << self loremIpsum; cr; cr.		5 atRandom timesRepeat: [			15 atRandom timesRepeat: [	 			out << words atRandom capitalized.				20 atRandom timesRepeat: [ out space; << words atRandom ].				out nextPut: $.; space ].			out cr; cr ] ] repeat! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!fromString: aString 	"Answer an instance of me that is a copy of the argument, aString."		^ aString copyFrom: 1 to: aString size! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!tab	"Answer a string containing a single tab character."	^ self with: Character tab! !!String class methodsFor: 'instance creation' stamp: 'yo 11/3/2004 19:24'!cr	"Answer a string containing a single carriage return character."	^ self with: Character cr! !!String class methodsFor: 'initialization' stamp: 'BenjaminVanRyseghem 11/24/2010 14:34'!initializeTypeTable	| newTable |	newTable := Array new: 256 withAll: #xBinary. "default"	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.	1 to: 255		do: [:index |			(Character value: index) isLetter				ifTrue: [newTable at: index put: #xLetter]].	newTable at: 30 put: #doIt.	newTable at: $" asciiValue put: #xDoubleQuote.	newTable at: $# asciiValue put: #xLitQuote.	newTable at: $$ asciiValue put: #xDollar.	newTable at: $' asciiValue put: #xSingleQuote.	newTable at: $: asciiValue put: #xColon.	newTable at: $( asciiValue put: #leftParenthesis.	newTable at: $) asciiValue put: #rightParenthesis.	newTable at: $. asciiValue put: #period.	newTable at: $; asciiValue put: #semicolon.	newTable at: $[ asciiValue put: #leftBracket.	newTable at: $] asciiValue put: #rightBracket.	newTable at: ${ asciiValue put: #leftBrace.	newTable at: $} asciiValue put: #rightBrace.	newTable at: $^ asciiValue put: #upArrow.	newTable at: $_ asciiValue put: #xLetter. "by default, do not accept _ as assignement"	newTable at: $| asciiValue put: #verticalBar.	TypeTable := newTable "bon voyage!!"! !!String class methodsFor: 'initialization' stamp: 'Spirita 6/24/2016 16:35'!newLowercasingTable	"a table for translating to lower case"	^ String withAll: (Character allByteCharacters collect: [:c | c asLowercase]).! !!String class methodsFor: 'initialization' stamp: 'Spirita 6/24/2016 16:26'!newCaseSensitiveOrder	"Case-sensitive compare sorts space, digits, letters, all the rest..."		| newTab order |	newTab := ByteArray new: 256 withAll: 255.	order := -1.	' 0123456789' do:  "0..10"		[:c | newTab at: c asciiValue + 1 put: (order := order+1)].	($a to: $z) do:     "11-64"		[:c | newTab  at: c asUppercase asciiValue + 1 put: (order := order+1).		newTab  at: c asciiValue + 1 put: (order := order+1)].	1 to: newTab  size do:		[:i | (newTab  at: i) = 255 ifTrue:			[newTab  at: i put: (order := order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	^ newTab ! !!String class methodsFor: 'initialization' stamp: 'Spirita 6/24/2016 17:03'!newCrLfExchangeTable	"a table for exchanging cr with lf and vica versa"	^ Character allByteCharacters collect: [ :each |		each = Character cr 			ifTrue: [ Character lf ]			ifFalse: [ 				each = Character lf					ifTrue: [ Character cr ]					ifFalse:[ each ]]]! !!String class methodsFor: 'initialization' stamp: 'Spirita 6/24/2016 16:09'!newAsciiOrder	^ (0 to: 255) as: ByteArray! !!String class methodsFor: 'initialization' stamp: 'Spirita 6/24/2016 17:04'!initialize   "self initialize"		self initializeTypeTable.		AsciiOrder := self newAsciiOrder.	CaseInsensitiveOrder := self newCaseInsensitiveOrder.	CaseSensitiveOrder := self newCaseSensitiveOrder.	LowercasingTable := self newLowercasingTable.	UppercasingTable := self newUppercasingTable.	Tokenish := self newTokenish.	CSLineEnders := self newCSLineEnders. 	"separators and non-separators"	CSSeparators := CharacterSet separators.	CSNonSeparators := CSSeparators complement.		CrLfExchangeTable := self newCrLfExchangeTable! !!String class methodsFor: 'initialization' stamp: 'Spirita 6/24/2016 16:53'!newTokenish	"a table for testing tokenish (for fast numArgs)"	^ String withAll: (Character allByteCharacters 		collect: [:c | c tokenish ifTrue: [ c ] ifFalse: [ $~ ]]).! !!String class methodsFor: 'initialization' stamp: 'Spirita 6/24/2016 16:50'!newUppercasingTable	"a table for translating to upper case"	^ String withAll: (Character allByteCharacters collect: [:c | c asUppercase]).! !!String class methodsFor: 'initialization' stamp: 'Spirita 6/24/2016 16:58'!newCSLineEnders	"CR and LF--characters that terminate a line"	^ CharacterSet crlf.! !!String class methodsFor: 'initialization' stamp: 'Spirita 6/24/2016 16:16'!newCaseInsensitiveOrder	"map char and char asLower (Lowercase Latin1 stays in the Latin1 range, uppercase not.)"	| newCollection |	newCollection := AsciiOrder copy.    (0 to: 255) do:[ :v |            | char lower |            char := v asCharacter.            lower := char asLowercase.            newCollection at: lower asciiValue + 1 put: (newCollection at: char asciiValue + 1) ].	^ newCollection ! !!String class methodsFor: 'primitives' stamp: 'MarianoMartinezPeck 10/29/2011 20:01'!translate: aString from: start  to: stop  table: table	"Trivial, non-primitive version"	| char |	start to: stop do: [:i |		(char := aString basicAt: i) < 256 ifTrue: [			aString at: i put: (table at: char+1)].	].! !!String class methodsFor: 'primitives' stamp: 'MarianoMartinezPeck 10/29/2011 19:59'!stringHash: aString initialHash: speciesHash	| stringSize hash low |	stringSize := aString size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash := hash + (aString basicAt: pos).		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash // 16384) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash.! !!String class methodsFor: 'primitives' stamp: 'MarianoMartinezPeck 10/29/2011 19:49'!findFirstInString: aString inSet: inclusionMap startingAt: start	"Trivial, non-primitive version"		| i stringSize ascii more |	inclusionMap size ~= 256 ifTrue: [^ 0].	stringSize := aString size.	more := true.	i := start - 1.	[more and: [(i := i + 1) <= stringSize]] whileTrue: [		ascii := (aString basicAt: i).		more := ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].	].	i > stringSize ifTrue: [^ 0].	^ i! !!String class methodsFor: 'primitives' stamp: 'nice 3/15/2007 20:59'!findFirstInString: aString inCharacterSet: aCharacterSet startingAt: start 	"Trivial, non-primitive version"		start		to: aString size		do: [:i | (aCharacterSet					includes: (aString at: i))				ifTrue: [^ i]].	^ 0! !!String class methodsFor: 'primitives' stamp: 'MarianoMartinezPeck 10/29/2011 19:48'!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	order == nil ifTrue: [		len1 := string1 size.		len2 := string2 size.		1 to: (len1 min: len2) do:[:i |			c1 := (string1 basicAt: i).			c2 := (string2 basicAt: i).			c1 = c2 ifFalse: [c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].		].		len1 = len2 ifTrue: [^ 2].		len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].	].	len1 := string1 size.	len2 := string2 size.	1 to: (len1 min: len2) do:[:i |		c1 := (string1 basicAt: i).		c2 := (string2 basicAt: i).		c1 < 256 ifTrue: [c1 := order at: c1 + 1].		c2 < 256 ifTrue: [c2 := order at: c2 + 1].		c1 = c2 ifFalse:[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].	].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!String class methodsFor: 'primitives' stamp: 'MarianoMartinezPeck 10/29/2011 19:53'!indexOfAscii: anInteger inString: aString startingAt: start		start to: aString size do: [ :index |		(aString basicAt: index) = anInteger ifTrue: [ ^index ] ].	^0! !!String class methodsFor: '*system-settings-browser' stamp: 'alain.plantec 3/18/2009 15:02'!settingInputWidgetForNode: aSettingNode	^ aSettingNode inputWidgetForString! !Party subclass: #Supplier	instanceVariableNames: 'customers name'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!Supplier methodsFor: 'as yet unclassified' stamp: 'GUidoTripodi 11/18/2017 13:59'!name: aName 	name := aName .! !!Supplier methodsFor: 'adding' stamp: 'guidotripodi 11/19/2017 11:14'!addCustomer: aCustomer 
"	[customers includes: aCustomer] ifNil: [
	customers add: aCustomer . ]."	"| collectCustomer |	collectCustomer := OrderedCollection new.	collectCustomer := customers select: [ :aCustom | aCustom identificationType = aCustomer identificationType and: [aCustom identificationNumber = aCustomer identificationNumber ] ].	collectCustomer isEmpty ifTrue: ["customers add: aCustomer "] . "! !!Supplier methodsFor: 'adding' stamp: 'guidotripodi 11/19/2017 11:22'!include: aCustomer 
^ (customers includes: aCustomer) ! !!Supplier methodsFor: 'adding' stamp: 'guidotripodi 11/19/2017 11:14'!customers
	^customers .! !!Supplier methodsFor: 'addresses' stamp: 'GUidoTripodi 11/18/2017 15:32'!persistInto: aSystem	aSystem persistSupplier: self.! !!Supplier methodsFor: 'initialization' stamp: 'GUidoTripodi 11/18/2017 15:02'!initialize	addresses := OrderedCollection new.	customers := OrderedCollection new.! !Object subclass: #SupplierImport	instanceVariableNames: 'line readStream session record system newSupplier newCustomer'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierImport methodsFor: 'importing' stamp: 'guidotriopodi 11/16/2017 20:40'!convertLineToRecord

	record := line substrings: {$,}.! !!SupplierImport methodsFor: 'importing' stamp: 'guidotripodi 11/19/2017 12:40'!importCustomer	newCustomer := (ImportData new) importNewCustomer: record.	system persistObject: newCustomer.	newCustomer supplierIdentificationNumber: newSupplier identificationNumber .	newCustomer supplierType: newSupplier identificationType .	newSupplier addCustomer: newCustomer.		! !!SupplierImport methodsFor: 'importing' stamp: 'guidotripodi 11/19/2017 10:35'!import

	[ self canImportNextLine ] whileTrue: [ 
		self convertLineToRecord.
		self importRecord ].! !!SupplierImport methodsFor: 'importing' stamp: 'guidotriopodi 11/16/2017 20:40'!canImportNextLine
	readStream ifNil: [^ self error: CustomerImport noCustomerForAddressErrorDescription ] .
	line := readStream nextLine.
	^ line notNil! !!SupplierImport methodsFor: 'importing' stamp: 'guidotripodi 11/18/2017 20:25'!importAddress	newCustomer		ifNil: [ ^ self error: CustomerImport noCustomerForAddressErrorDescription ].		^ newSupplier addAddress: ((ImportData new)  importNewAddress: record).! !!SupplierImport methodsFor: 'importing' stamp: 'guidotripodi 11/18/2017 21:48'!importRecord
			record first = 'S' ifTrue: [ ^self importSupplier ].	record first = 'NC' ifTrue: [ ^self importCustomer ].
	record first = 'EC' ifTrue: [ ^self addExistCustomer ].
	record first = 'A' ifTrue: [ ^self importAddress ].	^ self error: SupplierImport noCustomerForAddressErrorDescription.! !!SupplierImport methodsFor: 'importing' stamp: 'guidotripodi 11/18/2017 19:15'!importSupplierFromStream: aReadStream
	
	readStream := aReadStream .		self import.! !!SupplierImport methodsFor: 'as yet unclassified' stamp: 'guidotripodi 11/18/2017 21:51'!importSupplier		newSupplier := (ImportData new) importNewSupplier: record.	system persistObject: newSupplier! !!SupplierImport methodsFor: 'adding' stamp: 'guidotripodi 11/19/2017 12:37'!addExistCustomer	newCustomer := system  findCustomerByType: record second  andIdentification: record third .		[newSupplier include: newCustomer ] ifNil:  [	 	newCustomer supplierIdentificationNumber: newSupplier identificationNumber .		newCustomer supplierType: newSupplier identificationType .		newSupplier addCustomer: newCustomer 		.]! !!SupplierImport methodsFor: 'initialization' stamp: 'GUidoTripodi 11/18/2017 13:56'!initializeOn: aReadStream on: aSession

	readStream := aReadStream.
	system := aSession.! !!SupplierImport methodsFor: 'initialization' stamp: 'guidotripodi 11/18/2017 20:30'!initializeFromSystem: aSystem 	system := aSystem .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImport class	instanceVariableNames: ''!!SupplierImport class methodsFor: 'as yet unclassified' stamp: 'guidotripodi 11/17/2017 17:18'!fromSystem: aSystem 	^self new initializeFromSystem: aSystem ! !!SupplierImport class methodsFor: 'as yet unclassified' stamp: 'guidotriopodi 11/16/2017 20:40'!noCustomerForAddressErrorDescription		^'Datos de entrada invalidos. No se encuentra Customer para la direccion ingresada. Muchas gracias vuelva prontos.'! !!SupplierImport class methodsFor: 'instance creation' stamp: 'guidotriopodi 11/16/2017 20:40'!from: aReadStream on: aSession

	^self new initializeOn: aReadStream on: aSession! !TestCase subclass: #SupplierImportTest	instanceVariableNames: 'importer system inputStream'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'GUidoTripodi 11/18/2017 17:15'!validTestData	^ ReadStream on: 'S,Supplier1,D,123NC,Pepe,Sanchez,D,22333444NC,Arturo,Sanchez,D,12345EC,D,12345A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'guidotriopodi 11/16/2017 20:40'!emptyInput	^ ReadStream		on:			''! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'GUidoTripodi 11/18/2017 15:17'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber 	^ system supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'guidotriopodi 11/16/2017 20:40'!invalidDataInput1AddressOnly	^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'guidotriopodi 11/16/2017 20:40'!invalidDataInputFormated	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444,FloresA,San Martin,3322,Olivos,1636,BsAs,PeruA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!SupplierImportTest methodsFor: 'as yet unclassified' stamp: 'GUidoTripodi 11/18/2017 14:52'!dataInputCustomerNonExist	^ ReadStream on: 'S,Supplier1,D,123 NC,Pepe,Sanchez,D,22333444EC,D,5456774A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!SupplierImportTest methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 13:55'!importSupplierFrom: aInputStream
	| supplierImporter |	supplierImporter := SupplierImport  from: aInputStream on: system.	supplierImporter import! !!SupplierImportTest methodsFor: 'importing' stamp: 'guidotriopodi 11/16/2017 20:40'!importCustomersFrom: aInputStream
	| customer |	customer := CustomerImport from: aInputStream on: system.	customer import! !!SupplierImportTest methodsFor: 'importing' stamp: 'guidotriopodi 11/16/2017 20:40'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber
	
	^ system customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber! !!SupplierImportTest methodsFor: 'customers' stamp: 'guidotripodi 11/19/2017 11:59'!allCustomers
	^ system selectAllCustomers! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 12:56'!setUp
	system := Environment current newSupplierSystem.
	system start.
	system beginTransaction! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'guidotriopodi 11/16/2017 20:40'!addressMapping
	^ system addressMapping! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'guidotriopodi 11/16/2017 20:40'!customerMapping
	^ system customerMapping! !!SupplierImportTest methodsFor: 'setup-teardown' stamp: 'guidotriopodi 11/16/2017 20:40'!tearDown
	system commitTransaction.
	system stop! !!SupplierImportTest methodsFor: 'testing' stamp: 'GUidoTripodi 11/18/2017 14:52'!test05CustomerNoExistImposibleImporter	inputStream := self dataInputCustomerNonExist.self		should: [ self importSupplierFrom:  inputStream ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImport noExistCustomer ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'guidotriopodi 11/16/2017 20:43'!test03AddressWithNoCustomerShouldRaiseError	inputStream := self invalidDataInput1AddressOnly.self		should: [ self importSupplierFrom:  inputStream ]		raise: Error		withExceptionDo: [ :anError |			self assert: anError messageText = CustomerImport noCustomerForAddressErrorDescription ]! !!SupplierImportTest methodsFor: 'testing' stamp: 'guidotriopodi 11/16/2017 20:43'!test04InputEmptyShouldntRaiseErrors	self importSupplierFrom:  self emptyInput.	self assertCorrectNumberOfCustomersWereImported: 0.! !!SupplierImportTest methodsFor: 'testing' stamp: 'guidotripodi 11/19/2017 12:28'!test02verifyImportCustomerCorrectlyForReadStream

	self importSupplierFrom:  self validTestData.

	self assertCorrectNumberOfCustomersWereImported: 2.
	self assertPepeSanchezWasImportedCorrectly.! !!SupplierImportTest methodsFor: 'asserting' stamp: 'GUidoTripodi 11/18/2017 15:11'!assert: supplier hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province

	| address |
	
	address := supplier addressAt: streetName ifNone: [ self fail ].
	self assert: address streetName equals: streetName.
	self assert: address streetNumber equals: streetNumber.
	self assert: address town equals: town.
	self assert: address zipCode equals: zipCode.
	self assert: address province equals: province.
	! !!SupplierImportTest methodsFor: 'asserting' stamp: 'guidotripodi 11/19/2017 12:47'!assertCorrectNumberOfCustomersWereImported: aNumber self assert: (self allCustomers) size equals: aNumber ! !!SupplierImportTest methodsFor: 'asserting' stamp: 'GUidoTripodi 11/18/2017 15:16'!assertPepeSanchezWasImportedCorrectly
	| customer supplier |
	customer := self
		customerIdentifiedAs: 'D'
		numbered: '22333444'.	supplier := self supplierIdentifiedAs: 'D'
		numbered: '123'.
	self
		assert: customer
		isNamed: 'Pepe'
		lastName: 'Sanchez'
		identfiedAs: 'D'
		withNumber: '22333444'
		andNumberOfAddresses: 0.
	self
		assert: supplier
		hasAddressAt: 'San Martin'
		number: 3322
		in: 'Olivos'
		zipCode: 1636
		province: 'BsAs'.
	self
		assert: supplier
		hasAddressAt: 'Maipu'
		number: 888
		in: 'Florida'
		zipCode: 1122
		province: 'Buenos Aires'! !!SupplierImportTest methodsFor: 'asserting' stamp: 'GUidoTripodi 11/18/2017 16:29'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize

	self assert: customer firstName equals: firstName.
	self assert: customer lastName equals: lastName.
	self assert: customer identificationType equals: idType.
	self assert: customer identificationNumber equals: idNumber.
	self assert: (customer addresses size) equals: addressesSize .! !Object subclass: #SupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!persistObject: aPersistableObject 
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!customerIdentifiedAs: anIdentificationType numbered: anIdentificationNumber
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!commitTransaction
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!beginTransaction
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!start
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!findCustomerByType: aType andIdentification: aIndentification
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!persist: aCustomer
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber 
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!stop
	self subclassResponsibility! !!SupplierSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!selectAllCustomers
	self subclassResponsibility! !SupplierSystem subclass: #SupplierPersistentSystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:15'!persistObject: aPersistableObject 		aPersistableObject persistInto: self.! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!addressMapping
	^ ClassMapping
		withDefaultTableNameFor: Address
		mappingAll:
			(Array
				with: (EmbededMapping withDefaultFieldNameFor: #streetName)
				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)
				with: (EmbededMapping withDefaultFieldNameFor: #town)
				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)
				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!initialize
	super initialize.
	self initializeSession.! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!customerMapping
	^ ClassMapping
		withDefaultTableNameFor: Customer
		mappingAll:
			(Array
				with: (EmbededMapping withDefaultFieldNameFor: #firstName)
				with: (EmbededMapping withDefaultFieldNameFor: #lastName)
				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)
				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)
				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!commitTransaction
	session commit! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!beginTransaction
	session beginTransaction! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!start
	session open! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:46'!findCustomerByType: aType andIdentification: aIndentification	^self customerIdentifiedAs: aType  numbered: aIndentification! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!initializeSession
	session :=
			(DataBaseSession
				for: (Array with: self addressMapping with: self customerMapping with: self supplierMapping  ))! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:17'!persist: aCustomer 
	session persist: aCustomer! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 12:58'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber 	| suppliers |
	suppliers := session
		select: [ :aSupplier | 
			aSupplier identificationType = anIdentifycationType
				and: [ aSupplier identificationNumber = anIdentificationNumber ] ]
		ofType: Supplier .
	^ suppliers anyOne! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!supplierMapping
	^ ClassMapping
		withDefaultTableNameFor: Supplier 
		mappingAll:
			(Array
				with: (EmbededMapping withDefaultFieldNameFor: #name)
				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)
				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)
				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer))! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:17'!persistSupplier: aSupplier 
 session persist:  aSupplier! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'GUidoTripodi 11/18/2017 17:25'!stop
	session close! !!SupplierPersistentSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/19/2017 13:56'!persistCustomer: aCustomer 	"| customer |	customer := self customerIdentifiedAs2:  aCustomer identificationType   numbered: aCustomer identificationNumber .	customer = 'null' ifTrue: [ session persist: aCustomer ] ifFalse:['Relacionarlo con supplier']"! !!SupplierPersistentSystem methodsFor: 'customers' stamp: 'GUidoTripodi 11/18/2017 17:25'!selectAllCustomers
	^ session selectAllOfType: Customer! !!SupplierPersistentSystem methodsFor: 'importing' stamp: 'guidotripodi 11/19/2017 13:46'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber
	| customers|
	customers := session
		select: [ :aCustomer | 
			aCustomer identificationType = anIdentifycationType
				and: [ aCustomer identificationNumber = anIdentificationNumber ] ]
		ofType: Customer.		customers isEmpty ifFalse: [ ^ customers anyOne] ifTrue: [^ self error: CustomerImport noExistCustomer].! !SupplierSystem subclass: #SupplierTransientSystem	instanceVariableNames: 'customers session suppliers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-2-Model'!!SupplierTransientSystem methodsFor: 'initialization' stamp: 'GUidoTripodi 11/18/2017 17:25'!initialize
	super initialize.
	customers := OrderedCollection new.	suppliers := OrderedCollection new.! !!SupplierTransientSystem methodsFor: 'customers' stamp: 'GUidoTripodi 11/18/2017 17:25'!findCustomerByType: aType andIdentification: aIndentification
		| collectionCustomer |	collectionCustomer := OrderedCollection new.	collectionCustomer := ( customers select:[:customer | customer identificationType = aType and: ( customer identificationNumber = aIndentification )]).	collectionCustomer isEmpty ifFalse: [ ^(collectionCustomer first) ] ifTrue: [^ self error: CustomerImport noExistCustomer].! !!SupplierTransientSystem methodsFor: 'customers' stamp: 'GUidoTripodi 11/18/2017 17:25'!selectAllCustomers
	^ customers! !!SupplierTransientSystem methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 17:25'!beginTransaction! !!SupplierTransientSystem methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 17:25'!persistSupplier: aSupplier 
	suppliers  add: aSupplier! !!SupplierTransientSystem methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 17:25'!persist: aCustomer 
	customers add: aCustomer! !!SupplierTransientSystem methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 17:25'!persistCustomer: aCustomer 
	customers add: aCustomer! !!SupplierTransientSystem methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 17:25'!start
! !!SupplierTransientSystem methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 17:25'!commitTransaction
! !!SupplierTransientSystem methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 17:25'!persistObject: aPersistableObject 
	"customers add: aCustomer"	aPersistableObject persistInto: self.! !!SupplierTransientSystem methodsFor: 'importing' stamp: 'guidotripodi 11/20/2017 14:23'!customerIdentifiedAs: anIdentificationType numbered: anIdentificationNumber
	| identifiedCustomers identification |	identification := Identification type: anIdentificationType  number: anIdentificationNumber  .
	identifiedCustomers := (identification giveMeElementFrom: customers).
	^ identifiedCustomers first! !!SupplierTransientSystem methodsFor: 'importing' stamp: 'GUidoTripodi 11/18/2017 17:25'!stop
! !!SupplierTransientSystem methodsFor: 'setup-teardown' stamp: 'guidotripodi 11/20/2017 14:23'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	| identifiedSuppliers identification |	identification := Identification type: anIdentifycationType  number: anIdentificationNumber  .
	identifiedSuppliers := (identification giveMeElementFrom: suppliers).
	^ identifiedSuppliers first! !Object initialize!String initialize!